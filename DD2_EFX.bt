//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: DMC5_EFX
//   Authors: ZippoIG(thezippotm)
//   Version: 1.0
//   Purpose: Editing Street Fighter 6 EFX files.
//  Category: Modding
// File Mask: *.efx.3474275
//  ID Bytes: 65 66 78 72 //efxr
//   History: Made from Darkness' DMC5 EFX Template and with a little help from NSA Cloud's MHR EFX Template.

LittleEndian();
local int a <hidden=true>, b <hidden=true>,c <hidden=true>,d <hidden=true>,e <hidden=true>,f <hidden=true>,g <hidden=true>,h <hidden=true>,i <hidden=true>,j <hidden=true>,x <hidden=true>, y <hidden=true>,z <hidden=true>,p <hidden=true>,red <hidden=true>,green <hidden=true>,blue <hidden=true>,alpha <hidden=true>,onlyAlpha <hidden=true>,alphaLessRed <hidden=true>,alphaLessGreen <hidden=true>,alphaLessBlue <hidden=true>, c5it <hidden=true>, deb <hidden=true>;
local uint64 colorBitCount_arr[999] <hidden=true>, intCount_arr[999] <hidden=true>, redPos[999] <hidden=true>,greenPos[999] <hidden=true>,bluePos[999] <hidden=true>,alphaPos[999] <hidden=true>,spos[999] <hidden=true>,mpos[999] <hidden=true>,lpos[999] <hidden=true>,fpos[999] <hidden=true>,onlyAlphaPos[999] <hidden=true>,alphaLessRedPos[999] <hidden=true>,alphaLessGreenPos[999] <hidden=true>,alphaLessBluePos[999] <hidden=true>, backPos <hidden=true>, backPoseSC <hidden=true>, backPoseSCin <hidden=true>, debug[50] <hidden=true>;
alphaLessRed = 0,alphaLessGreen = 0,alphaLessBlue = 0,onlyAlpha = 0,red = 0,green = 0,blue = 0,alpha = 0,h = 0,i = 0,j = 0,p = 0;

enum EffectGraphType
{
	ItemType_0x01_001 = 0x01,
	ItemType_0x02_002 = 0x02,
	ItemType_0x04_004 = 0x04,
	ItemType_0x08_008 = 0x08,
    ItemType_Transform3D = 0x09,
	ItemType_0x0A_010 = 0x0A,
	ItemType_0x0B_011 = 0x0B,
	ItemType_0x0C_012 = 0x0C,
	ItemType_0x0D_013 = 0x0D,
	ItemType_ParentOptions = 0x0E,
	ItemType_0x0F_015 = 0x0F,
	ItemType_Spawn = 0x10,
	ItemType_0x11_017 = 0x11,
	ItemType_0x12_018 = 0x12,
	ItemType_0x13_019 = 0x13, // Like PtColorClip
	ItemType_0x15_021 = 0x15,
	ItemType_0x16_022 = 0x16,
	ItemType_0x17_023 = 0x17,
	ItemType_TypeBillboard3D = 0x18,
	ItemType_0x19_025 = 0x19,
	ItemType_0x1A_026 = 0x1A, // Type Billboard3D Material
	ItemType_0x1B_027 = 0x1B,
	ItemType_0x1C_028 = 0x1C,
	ItemType_TypeMesh = 0x1D,
	ItemType_0x1E_030 = 0x1E,
	ItemType_0x1F_031 = 0x1F,
	ItemType_0x20_032 = 0x20,
	ItemType_0x21_033 = 0x21,
	ItemType_0x22_034 = 0x22,
	ItemType_0x23_035 = 0x23,
	ItemType_0x24_036 = 0x24,
	ItemType_0x25_037 = 0x25,
	ItemType_0x26_038 = 0x26,
	ItemType_0x27_039 = 0x27,
	ItemType_0x28_040 = 0x28,
	ItemType_0x29_041 = 0x29,
	ItemType_0x2B_043 = 0x2B,
	ItemType_0x2C_044 = 0x2C,
	ItemType_0x2D_045 = 0x2D,
	ItemType_0x2E_046 = 0x2E,
	ItemType_0x2F_047 = 0x2F,
	ItemType_0x30_048 = 0x30,
	ItemType_0x31_049 = 0x31,
	ItemType_0x35_053 = 0x35,
	ItemType_0x36_054 = 0x36,
	ItemType_0x37_055 = 0x37,
	ItemType_0x3B_059 = 0x3B,
	ItemType_0x3C_060 = 0x3C,
	ItemType_0x3D_061 = 0x3D,
	ItemType_0x3E_062 = 0x3E,
	ItemType_0x40_064 = 0x40,
	ItemType_TypePolygon = 0x41,
	ItemType_0x43_067 = 0x43,
	ItemType_0x44_068 = 0x44,
	ItemType_0x48_072 = 0x48,
	ItemType_0x4A_074 = 0x4A,
	ItemType_0x4C_076 = 0x4C,
	ItemType_TypeNoDraw = 0x4D, //TypeNoDraw
	ItemType_0x4E_078 = 0x4E,
	ItemType_0x50_080 = 0x50,
	ItemType_0x51_081 = 0x51,
	ItemType_0x52_082 = 0x52,
	ItemType_Velocity3D = 0x53,
	ItemType_0x54_084 = 0x54,
	ItemType_RotateAnim = 0x56,
	ItemType_0x57_087 = 0x57,
	ItemType_0x58_088 = 0x58,
	ItemType_ScaleAnim = 0x59,
	ItemType_0x5A_090 = 0x5A,
	ItemType_0x5B_091 = 0x5B,
	ItemType_0x5C_092 = 0x5C,
	ItemType_Life = 0x5D,
	ItemType_0x5E_094 = 0x5E,
	ItemType_UVSequence = 0x5F,
	ItemType_0x60_096 = 0x60,
	ItemType_0x61_097 = 0x61,
	ItemType_0x62_098 = 0x62, // UV Scroll
	ItemType_0x63_099 = 0x63,
	ItemType_0x64_100 = 0x64,
	ItemType_0x65_101 = 0x65,
	ItemType_0x66_102 = 0x66,
	ItemType_0x6A_106 = 0x6A,
	ItemType_0x67_103 = 0x67,
	ItemType_EmitterShape3D = 0x68, // Emitter Shape 3D
	ItemType_0x69_105 = 0x69,
	ItemType_0x6C_108 = 0x6C,
	ItemType_0x6E_110 = 0x6E,
	ItemType_0x6F_111 = 0x6F,
	ItemType_0x70_112 = 0x70,
	ItemType_0x71_113 = 0x71,
	ItemType_0x74_116 = 0x74,
	ItemType_0x75_117 = 0x75,
	ItemType_0x76_118 = 0x76,
	ItemType_0x77_119 = 0x77,
	ItemType_0x78_120 = 0x78,
	ItemType_0x79_121 = 0x79,
	ItemType_0x7A_122 = 0x7A,
	ItemType_ShaderSettings = 0x7E, // Shader Settings
	ItemType_0x7F_127 = 0x7F,
	ItemType_0x80_128 = 0x80,
	ItemType_0x81_129 = 0x81,
	ItemType_0x85_133 = 0x85,
	ItemType_0x86_134 = 0x86,
	ItemType_0x87_135 = 0x87,
	ItemType_PtBehavior = 0x88,
	ItemType_0x8B_139 = 0x8B,
	ItemType_0x8D_141 = 0x8D,
	ItemType_0x8E_142 = 0x8E,
	ItemType_0x8F_143 = 0x8F,
	ItemType_0x90_144 = 0x90,
	ItemType_0x92_146 = 0x92,
	ItemType_0x93_147 = 0x93,
	ItemType_0x94_148 = 0x94,
	ItemType_0x95_149 = 0x95,
	ItemType_0x96_150 = 0x96,
	ItemType_0x98_152 = 0x98,
	ItemType_0x9A_154 = 0x9A,
	ItemType_0x9B_155 = 0x9B,
	ItemType_0x9E_158 = 0x9E,
	ItemType_0x9F_159 = 0x9F,
	ItemType_0xA0_160 = 0xA0,
	ItemType_0xA1_161 = 0xA1,
	ItemType_0xA3_163 = 0xA3,
	ItemType_0xA4_164 = 0xA4,
	ItemType_0xA5_165 = 0xA5,
	ItemType_0xA7_167 = 0xA7,
	ItemType_0xA8_168 = 0xA8,
	ItemType_PtColor = 0xAA,
	ItemType_PtColorClip = 0xAB,
	ItemType_0xAE_174 = 0xAE,
	ItemType_0xAF_175 = 0xAF,
	ItemType_0xB0_176 = 0xB0, // MeshEmitter?
	ItemType_0xB3_179 = 0xB3,
	ItemType_0xB5_181 = 0xB5,
	ItemType_0xB6_182 = 0xB6,
	ItemType_0xB7_183 = 0xB7,
	ItemType_0xBE_190 = 0xBE,
	ItemType_0xBF_191 = 0xBF,
	ItemType_0xC1_193 = 0xC1,
	ItemType_0xC4_196 = 0xC4,
	ItemType_0xC5_197 = 0xC5,
	ItemType_0xC6_198 = 0xC6,
	ItemType_0xC7_199 = 0xC7,
	ItemType_0xC8_200 = 0xC8,
	ItemType_0xD5_213 = 0xD5,
	ItemType_0xD6_214 = 0xD6,
	ItemType_0xDA_218 = 0xDA,
	ItemType_0xDB_219 = 0xDB,
	ItemType_0xDC_220 = 0xDC,
	ItemType_0xDD_221 = 0xDD,
	ItemType_0xDF_223 = 0xDF,
	ItemType_0xE0_224 = 0xE0,
	ItemType_0xE1_225 = 0xE1,
	ItemType_0xE2_226 = 0xE2,
	ItemType_0xE6_230 = 0xE6,
	ItemType_0xE7_231 = 0xE7,
	ItemType_0xE8_232 = 0xE8,
	ItemType_0xEF_239 = 0xEF,
	ItemType_0xF0_240 = 0xF0,
	ItemType_0xF1_241 = 0xF1,
	ItemType_0xF3_243 = 0xF3,
	ItemType_0xF4_244 = 0xF4,
	ItemType_0xF5_245 = 0xF5,
	ItemType_0xF7_247 = 0xF7,
	ItemType_0xF9_249 = 0xF9,
	ItemType_0xFA_250 = 0xFA,
	ItemType_0xFC_252 = 0xFC,
	ItemType_0xFD_253 = 0xFD,
	ItemType_0xFE_254 = 0xFE,
	ItemType_0xFF_255 = 0xFF,
	ItemType_0x100_256 = 0x100,
	ItemType_0x101_257 = 0x101,
	ItemType_0x102_258 = 0x102,
	ItemType_0x103_259 = 0x103,
	ItemType_0x104_260 = 0x104,
	ItemType_0x105_261 = 0x105, // Wrong
	ItemType_0x106_262 = 0x106,
	ItemType_0x107_263 = 0x107,
	ItemType_0x108_264 = 0x108,
	ItemType_0x109_265 = 0x109,
	ItemType_0x10A_266 = 0x10A
	
};

string GetSegmentName(struct Segment& segment){
    switch(segment.typeId){
	
	case ItemType_0x01_001:
		return "Unknown_ItemType_0x01_001";
		break;
	
	case ItemType_0x02_002:
		return "Unknown_ItemType_0x02_002";
		break;
	
	case ItemType_0x04_004:
		return "Unknown_ItemType_0x04_004";
		break;
	
	case ItemType_0x08_008:
		return "Unknown_ItemType_0x08_008";
		break;
	
	case ItemType_Transform3D:
		return "Transform 3D";
		break;
		
	case ItemType_0x0A_010:
		return "Unknown_ItemType_0x0A_010";
		break;
		
	case ItemType_0x0B_011:
		return "Unknown_ItemType_0x0B_011";
		break;
		
	case ItemType_0x0C_012:
		return "Unknown_ItemType_0x0C_012";
		break;
		
	case ItemType_0x0D_013:
		return "Unknown_ItemType_0x0D_013";
		break;
	
	case ItemType_ParentOptions:
		return "Parent Options";
		break;
		
	case ItemType_0x0F_015:
		return "Unknown_ItemType_0x0F_015";
		break;
		
	case ItemType_Spawn:
		return "Spawn";
		break;
		
	case ItemType_0x11_017:
		return "Unknown_ItemType_0x11_017";
		break;
		
	case ItemType_0x12_018:
		return "Unknown_ItemType_0x12_018";
		break;
		
	case ItemType_0x13_019:
		return "Unknown_ItemType_0x13_019";
		break;
		
	case ItemType_0x15_021:
		return "Unknown_ItemType_0x15_021";
		break;
		
	case ItemType_0x16_022:
		return "Unknown_ItemType_0x16_022";
		break;
		
	case ItemType_0x17_023:
		return "Unknown_ItemType_0x17_023";
		break;
		
	case ItemType_TypeBillboard3D:
		return "Type Billboard 3D";
		break;
		
	case ItemType_0x19_025:
		return "Unknown_ItemType_0x19_025";
		break;
		
	case ItemType_0x1A_026:
		return "Unknown_ItemType_0x1A_026";
		break;
		
	case ItemType_0x1B_027:
		return "Unknown_ItemType_0x1B_027";
		break;
		
	case ItemType_0x1C_028:
		return "Unknown_ItemType_0x1C_028";
		break;
		
	case ItemType_TypeMesh:
		return "Type Mesh";
		break;
		
	case ItemType_0x1E_030:
		return "Unknown_ItemType_0x1E_030";
		break;
		
	case ItemType_0x1F_031:
		return "Unknown_ItemType_0x1F_031";
		break;
		
	case ItemType_0x20_032:
		return "Unknown_ItemType_0x20_032";
		break;
		
	case ItemType_0x21_033:
		return "Unknown_ItemType_0x21_033";
		break;
		
	case ItemType_0x22_034:
		return "Unknown_ItemType_0x22_034";
		break;
		
	case ItemType_0x23_035:
		return "Unknown_ItemType_0x23_035";
		break;
		
	case ItemType_0x24_036:
		return "Unknown_ItemType_0x24_036";
		break;
		
	case ItemType_0x25_037:
		return "Unknown_ItemType_0x25_037";
		break;
		
	case ItemType_0x26_038:
		return "Unknown_ItemType_0x26_038";
		break;
		
	case ItemType_0x27_039:
		return "Unknown_ItemType_0x27_039";
		break;
		
	case ItemType_0x28_040:
		return "Unknown_ItemType_0x28_040";
		break;
		
	case ItemType_0x29_041:
		return "Unknown_ItemType_0x29_041";
		break;
		
	case ItemType_0x2B_043:
		return "Unknown_ItemType_0x2B_043";
		break;
		
	case ItemType_0x2C_044:
		return "Unknown_ItemType_0x2C_044";
		break;
		
	case ItemType_0x2D_045:
		return "Unknown_ItemType_0x2D_045";
		break;
		
	case ItemType_0x2E_046:
		return "Unknown_ItemType_0x2E_046";
		break;
		
	case ItemType_0x2F_047:
		return "Unknown_ItemType_0x2F_047";
		break;
		
	case ItemType_0x30_048:
		return "Unknown_ItemType_0x30_048";
		break;
		
	case ItemType_0x31_049:
		return "Unknown_ItemType_0x31_049";
		break;
		
	case ItemType_0x35_053:
		return "Unknown_ItemType_0x35_053";
		break;
		
	case ItemType_0x36_054:
		return "Unknown_ItemType_0x36_054";
		break;
		
	case ItemType_0x37_055:
		return "Unknown_ItemType_0x37_055";
		break;
		
	case ItemType_0x3B_059:
		return "Unknown_ItemType_0x3B_059";
		break;
		
	case ItemType_0x3C_060:
		return "Unknown_ItemType_0x3C_060";
		break;
		
	case ItemType_0x3D_061:
		return "Unknown_ItemType_0x3D_061";
		break;
		
	case ItemType_0x3E_062:
		return "Unknown_ItemType_0x3E_062";
		break;
		
	case ItemType_0x40_064:
		return "Unknown_ItemType_0x40_064";
		break;
		
	case ItemType_TypePolygon:
		return "Type Polygon";
		break;
		
	case ItemType_0x44_068:
		return "Unknown_ItemType_0x44_068";
		break;
		
	case ItemType_0x43_067:
		return "Unknown_ItemType_0x43_067";
		break;
		
	case ItemType_0x48_072:
		return "Unknown_ItemType_0x48_072";
		break;
		
	case ItemType_0x4A_074:
		return "Unknown_ItemType_0x4A_074";
		break;
		
	case ItemType_0x4C_076:
		return "Unknown_ItemType_0x4C_076";
		break;
		
	case ItemType_TypeNoDraw:
		return "Type No Draw";
		break;
		
	case ItemType_0x4E_078:
		return "Unknown_ItemType_0x4E_078";
		break;
		
	case ItemType_0x50_080:
		return "Unknown_ItemType_0x50_080";
		break;
		
	case ItemType_0x51_081:
		return "Unknown_ItemType_0x51_081";
		break;
		
	case ItemType_0x52_082:
		return "Unknown_ItemType_0x52_082";
		break;
		
	case ItemType_Velocity3D:
		return "Velocity 3D";
		break;
		
	case ItemType_0x54_084:
		return "Unknown_ItemType_0x54_084";
		break;
		
	case ItemType_RotateAnim:
		return "Rotate Anim";
		break;
		
	case ItemType_0x57_087:
		return "Unknown_ItemType_0x57_087";
		break;
		
	case ItemType_0x58_088:
		return "Unknown_ItemType_0x58_088";
		break;
		
	case ItemType_ScaleAnim:
		return "Scale Anim";
		break;
		
	case ItemType_0x5A_090:
		return "Unknown_ItemType_0x5A_090";
		break;
		
	case ItemType_0x5B_091:
		return "Unknown_ItemType_0x5B_091";
		break;
		
	case ItemType_0x5C_092:
		return "Unknown_ItemType_0x5C_092";
		break;
		
	case ItemType_Life:
		return "Life";
		break;
		
	case ItemType_0x5E_094:
		return "Unknown_ItemType_0x5E_094";
		break;
		
	case ItemType_UVSequence:
		return "UV Sequence";
		break;
		
	case ItemType_0x60_096:
		return "Unknown_ItemType_0x60_096";
		break;
		
	case ItemType_0x61_097:
		return "Unknown_ItemType_0x61_097";
		break;
		
	case ItemType_0x62_098:
		return "Unknown_ItemType_0x62_098";
		break;
		
	case ItemType_0x63_099:
		return "Unknown_ItemType_0x63_099";
		break;
		
	case ItemType_0x64_100:
		return "Unknown_ItemType_0x64_100";
		break;
		
	case ItemType_0x65_101:
		return "Unknown_ItemType_0x65_101";
		break;
		
	case ItemType_0x66_102:
		return "Unknown_ItemType_0x66_102";
		break;
		
	case ItemType_0x6A_106:
		return "Unknown_ItemType_0x6A_106";
		break;
		
	case ItemType_0x67_103:
		return "Unknown_ItemType_0x67_103";
		break;
		
	case ItemType_EmitterShape3D:
		return "Emitter Shape 3D";
		break;
		
	case ItemType_0x69_105:
		return "Unknown_ItemType_0x69_105";
		break;
		
	case ItemType_0x6C_108:
		return "Unknown_ItemType_0x6C_108";
		break;
		
	case ItemType_0x6E_110:
		return "Unknown_ItemType_0x6E_110";
		break;
		
	case ItemType_0x6F_111:
		return "Unknown_ItemType_0x6F_111";
		break;
		
	case ItemType_0x70_112:
		return "Unknown_ItemType_0x70_112";
		break;
		
	case ItemType_0x71_113:
		return "Unknown_ItemType_0x71_113";
		break;
		
	case ItemType_0x74_116:
		return "Unknown_ItemType_0x74_116";
		break;
		
	case ItemType_0x75_117:
		return "Unknown_ItemType_0x75_117";
		break;
		
	case ItemType_0x76_118:
		return "Unknown_ItemType_0x76_118";
		break;
		
	case ItemType_0x77_119:
		return "Unknown_ItemType_0x77_119";
		break;
		
	case ItemType_0x78_120:
		return "Unknown_ItemType_0x78_120";
		break;
		
	case ItemType_0x79_121:
		return "Unknown_ItemType_0x79_121";
		break;
		
	case ItemType_0x7A_122:
		return "Unknown_ItemType_0x7A_122";
		break;
		
	case ItemType_ShaderSettings:
		return "Shader Settings";
		break;
		
	case ItemType_0x7F_127:
		return "Unknown_ItemType_0x7F_127";
		break;
	
	case ItemType_0x80_128:
		return "Unknown_ItemType_0x80_128";
		break;
		
	case ItemType_0x81_129:
		return "Unknown_ItemType_0x81_129";
		break;
		
	case ItemType_0x85_133:
		return "Unknown_ItemType_0x85_133";
		break;
		
	case ItemType_0x86_134:
		return "Unknown_ItemType_0x86_134";
		break;
		
	case ItemType_0x87_135:
		return "Unknown_ItemType_0x87_135";
		break;
		
	case ItemType_PtBehavior:
		return "Pt Behavior";
		break;
		
	case ItemType_0x8B_139:
		return "Unknown_ItemType_0x8B_139";
		break;
		
	case ItemType_0x8D_141:
		return "Unknown_ItemType_0x8D_141";
		break;
		
	case ItemType_0x8E_142:
		return "Unknown_ItemType_0x8E_142";
		break;
		
	case ItemType_0x8F_143:
		return "Unknown_ItemType_0x8F_143";
		break;
		
	case ItemType_0x90_144:
		return "Unknown_ItemType_0x90_144";
		break;
		
	case ItemType_0x92_146:
		return "Unknown_ItemType_0x92_146";
		break;
		
	case ItemType_0x93_147:
		return "Unknown_ItemType_0x93_147";
		break;
		
	case ItemType_0x94_148:
		return "Unknown_ItemType_0x94_148";
		break;
	
	case ItemType_0x95_149:
		return "Unknown_ItemType_0x95_149";
		break;
		
	case ItemType_0x96_150:
		return "Unknown_ItemType_0x96_150";
		break;
		
	case ItemType_0x98_152:
		return "Unknown_ItemType_0x98_152";
		break;
		
	case ItemType_0x9A_154:
		return "Unknown_ItemType_0x9A_154";
		break;
		
	case ItemType_0x9B_155:
		return "Unknown_ItemType_0x9B_155";
		break;
		
	case ItemType_0x9E_158:
		return "Unknown_ItemType_0x9E_158";
		break;
		
	case ItemType_0x9F_159:
		return "Unknown_ItemType_0x9F_159";
		break;
		
	case ItemType_0xA0_160:
		return "Unknown_ItemType_0xA0_160";
		break;
		
	case ItemType_0xA1_161:
		return "Unknown_ItemType_0xA1_161";
		break;
		
	case ItemType_0xA3_163:
		return "Unknown_ItemType_0xA3_163";
		break;
		
	case ItemType_0xA4_164:
		return "Unknown_ItemType_0xA4_164";
		break;
		
	case ItemType_0xA5_165:
		return "Unknown_ItemType_0xA5_165";
		break;
		
	case ItemType_0xA7_167:
		return "Unknown_ItemType_0xA7_167";
		break;
		
	case ItemType_0xA8_168:
		return "Unknown_ItemType_0xA8_168";
		break;
		
	case ItemType_PtColor:
		return "Pt Color";
		break;
		
	case ItemType_PtColorClip:
		return "Pt Color Clip";
		break;
		
	case ItemType_0xAE_174:
		return "Unknown_ItemType_0xAE_174";
		break;
		
	case ItemType_0xAF_175:
		return "Unknown_ItemType_0xAF_175";
		break;
		
	case ItemType_0xB0_176:
		return "Unknown_ItemType_0xB0_176";
		break;
		
	case ItemType_0xB3_179:
		return "Unknown_ItemType_0xB3_179";
		break;
		
	case ItemType_0xB5_181:
		return "Unknown_ItemType_0xB5_181";
		break;
		
	case ItemType_0xB6_182:
		return "Unknown_ItemType_0xB6_182";
		break;
		
	case ItemType_0xB7_183:
		return "Unknown_ItemType_0xB7_183";
		break;
		
	case ItemType_0xBE_190:
		return "Unknown_ItemType_0xBE_190";
		break;
		
	case ItemType_0xBF_191:
		return "Unknown_ItemType_0xBF_191";
		break;
		
	case ItemType_0xC1_193:
		return "Unknown_ItemType_0xC1_193";
		break;
		
	case ItemType_0xC4_196:
		return "Unknown_ItemType_0xC4_196";
		break;
		
	case ItemType_0xC5_197:
		return "Unknown_ItemType_0xC5_197";
		break;
		
	case ItemType_0xC6_198:
		return "Unknown_ItemType_0xC6_198";
		break;
		
	case ItemType_0xC7_199:
		return "Unknown_ItemType_0xC7_199";
		break;
		
	case ItemType_0xC8_200:
		return "Unknown_ItemType_0xC8_200";
		break;
		
	case ItemType_0xD5_213:
		return "Unknown_ItemType_0xD5_213";
		break;
		
	case ItemType_0xD6_214:
		return "Unknown_ItemType_0xD6_214";
		break;
		
	case ItemType_0xDA_218:
		return "Unknown_ItemType_0xDA_218";
		break;
		
	case ItemType_0xDB_219:
		return "Unknown_ItemType_0xDB_219";
		break;
		
	case ItemType_0xDC_220:
		return "Unknown_ItemType_0xDC_220";
		break;
		
	case ItemType_0xDD_221:
		return "Unknown_ItemType_0xDD_221";
		break;
		
	case ItemType_0xDF_223:
		return "Unknown_ItemType_0xDF_223";
		break;
		
	case ItemType_0xE0_224:
		return "Unknown_ItemType_0xE0_224";
		break;
		
	case ItemType_0xE1_225:
		return "Unknown_ItemType_0xE1_225";
		break;
		
	case ItemType_0xE2_226:
		return "Unknown_ItemType_0xE2_226";
		break;
		
	case ItemType_0xE6_230:
		return "Unknown_ItemType_0xE6_230";
		break;
		
	case ItemType_0xE7_231:
		return "Unknown_ItemType_0xE7_231";
		break;
		
	case ItemType_0xE8_232:
		return "Unknown_ItemType_0xE8_232";
		break;
		
	case ItemType_0xEF_239:
		return "Unknown_ItemType_0xEF_239";
		break;
		
	case ItemType_0xF0_240:
		return "Unknown_ItemType_0xF0_240";
		break;
		
	case ItemType_0xF1_241:
		return "Unknown_ItemType_0xF1_241";
		break;
		
	case ItemType_0xF3_243:
		return "Unknown_ItemType_0xF3_243";
		break;
		
	case ItemType_0xF4_244:
		return "Unknown_ItemType_0xF4_244";
		break;
		
	case ItemType_0xF5_245:
		return "Unknown_ItemType_0xF5_245";
		break;
		
	case ItemType_0xF7_247:
		return "Unknown_ItemType_0xF7_247";
		break;
		
	case ItemType_0xF9_249:
		return "Unknown_ItemType_0xF9_249";
		break;
		
	case ItemType_0xFA_250:
		return "Unknown_ItemType_0xFA_250";
		break;
		
	case ItemType_0xFC_252:
		return "Unknown_ItemType_0xFC_252";
		break;
		
	case ItemType_0xFD_253:
		return "Unknown_ItemType_0xFD_253";
		break;
		
	case ItemType_0xFE_254:
		return "Unknown_ItemType_0xFE_254";
		break;
		
	case ItemType_0xFF_255:
		return "Unknown_ItemType_0xFF_255";
		break;
		
	case ItemType_0x100_256:
		return "Unknown_ItemType_0x100_256";
		break;
		
	case ItemType_0x101_257:
		return "Unknown_ItemType_0x101_257";
		break;
		
	case ItemType_0x102_258:
		return "Unknown_ItemType_0x102_258";
		break;
		
	case ItemType_0x103_259:
		return "Unknown_ItemType_0x103_259";
		break;
		
	case ItemType_0x104_260:
		return "Unknown_ItemType_0x104_260";
		break;
		
	case ItemType_0x105_261:
		return "Unknown_ItemType_0x105_261";
		break;
		
	case ItemType_0x106_262:
		return "Unknown_ItemType_0x106_262";
		break;
		
	case ItemType_0x107_263:
		return "Unknown_ItemType_0x107_263";
		break;
		
	case ItemType_0x108_264:
		return "Unknown_ItemType_0x108_264";
		break;
		
	case ItemType_0x109_265:
		return "Unknown_ItemType_0x109_265";
		break;
		
	case ItemType_0x10A_266:
		return "Unknown_ItemType_0x10A_266";
		break;
	
    }

    return "Unknown!";
}

typedef struct{
	ubyte   colorRed <name="Red", bgcolor=0x9B9BFF>;
	ubyte   colorGreen <name="Green", bgcolor=0x67AA67>;
	ubyte   colorBlue <name="Blue", bgcolor=0xFF9B9B>;
	ubyte   colorAlpha <name="Alpha", bgcolor=0x9BFFFF>;
} small_cc <name="Small Color Code">;

typedef struct{
	ubyte   colorRed <name="Red", bgcolor=0x9B9BFF>;
	ubyte   colorGreen <name="Green", bgcolor=0x67AA67>;
	ubyte   colorBlue <name="Blue", bgcolor=0xFF9B9B>;
	ubyte   colorAlpha <name="Alpha", bgcolor=0x9BFFFF>;
	ubyte   colorRed2 <name="Red", bgcolor=0x9B9BFF>;
	ubyte   colorGreen2 <name="Green", bgcolor=0x67AA67>;
	ubyte   colorBlue2 <name="Blue", bgcolor=0xFF9B9B>;
	ubyte   colorAlpha2 <name="Alpha", bgcolor=0x9BFFFF>;
	float   ukn_float <name="Might be brightness">;
} mid_cc <name="Medium Color Code">;

typedef struct{
	ubyte   colorRed <name="Red", bgcolor=0x9B9BFF>;
	ubyte   colorGreen <name="Green", bgcolor=0x67AA67>;
	ubyte   colorBlue <name="Blue", bgcolor=0xFF9B9B>;
	ubyte   colorAlpha <name="Alpha", bgcolor=0x9BFFFF>;
	ubyte   colorRed2 <name="Red", bgcolor=0x9B9BFF>;
	ubyte   colorGreen2 <name="Green", bgcolor=0x67AA67>;
	ubyte   colorBlue2 <name="Blue", bgcolor=0xFF9B9B>;
	ubyte   colorAlpha2 <name="Alpha", bgcolor=0x9BFFFF>;
	ubyte   colorRed3 <name="Red", bgcolor=0x9B9BFF>;
	ubyte   colorGreen3 <name="Green", bgcolor=0x67AA67>;
	ubyte   colorBlue3 <name="Blue", bgcolor=0xFF9B9B>;
	ubyte   colorAlpha3 <name="Alpha", bgcolor=0x9BFFFF>;;
	float   Brightness <name="Might be brightness">;
} large_cc <name="Large Color Code">;

typedef struct{
    float  red <name="Float Red", bgcolor=0x9B9BFF>;
    float  green <name="Float Green", bgcolor=0x67AA67>;
    float  blue <name="Float Blue", bgcolor=0xFF9B9B>;
    float  brightness <name="Float Brightness", bgcolor=0x9BFFFF>;
} float_cc <name="Float Color Code">;

typedef struct{
    uint32  size <name="UVS Path Size">;
    local uint64 pos <hidden=true> = FTell();
    if(size) wchar_t path[size] <name="UVS Path", bgcolor=0x99FF99, open=suppress>; else local wstring path <hidden=true> = "No Path Linked!";
} uvs_t <read=Read_UVS, write=Write_UVS, open=suppress>;

wstring Read_UVS(uvs_t &input){
    return input.path;
}

void Write_UVS(uvs_t &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(!Strlen(s)) size = 0;
    local uint32 bSize = input.size;
    if(bSize) DeleteBytes(input.pos, input.size * 2);
    if(size){
        InsertBytes(input.pos, size, 0x00);
        WriteWString(input.pos, (wstring)s);
        input.size = Strlen(s) + 1;
    } else {
       input.size = 0; 
    }
    if(!bSize)input.path = s;
}

typedef struct{
    uint32  size <name="MSK4 Path Size">;
    local uint64 pos <hidden=true> = FTell();
    if(size) wchar_t path[size] <name="MSK4 Path", bgcolor=0xFFC1C1, open=suppress>; else local wstring path <hidden=true> = "No Path Linked!";
} msk4_t <read=Read_MSK4, write=Write_MSK4, open=suppress>;

wstring Read_MSK4(msk4_t &input){
    return input.path;
}

void Write_MSK4(msk4_t &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(!Strlen(s)) size = 0;
    local uint32 bSize = input.size;
    if(bSize) DeleteBytes(input.pos, input.size * 2);
    if(size){ 
        InsertBytes(input.pos, size, 0x00);
        WriteWString(input.pos, (wstring)s);
        input.size = Strlen(s) + 1;
    } else {
       input.size = 0; 
    }
    if(!bSize)input.path = s;
}

typedef struct{
    uint32 size <name="Bone Name Size", bgcolor=0xC0FFC0>;
    local uint64 pos <hidden=true> = FTell();
    if(size == 0x02){
        wchar_t bone[1] <bgcolor=0xABA8FF, name="Bone Name">;
    } else if(size > 0x02){
        wchar_t bone[size/2] <bgcolor=0x99CCFF, name="Bone Name", open=suppress>;
    }
} bone_t <read=Read_Bone, write=Write_Bone, open=suppress>;

wstring Read_Bone(bone_t &input){
    if(input.size == 0x02 || input.size == 0x00){
        return (wstring)"No Bone Linked!";
    } else{
        return input.bone;
    }
}

void Write_Bone(bone_t &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(input.size) DeleteBytes(input.pos, input.size);
    InsertBytes(input.pos, size, 0x00);
    WriteWString(input.pos, (wstring)s);
    input.size = (Strlen(s) + 1) * 2;
}

typedef struct{
    uint32 size <name="Mesh Path Size">;
    local uint64 pos <hidden=true> = FTell();
    if(size == 0x02){
        wchar_t path[1] <bgcolor=0xABA8FF, name="Mesh Path">;
    } else if(size > 0x02){
        wchar_t path[size/2] <bgcolor=0x99FF99, name="Mesh Path", open=suppress>;
    }
} mesh_path <read=Read_Mesh_Path, write=Write_Mesh_Path, open=suppress>;

wstring Read_Mesh_Path(mesh_path &input){
    if(input.size == 0x02 || input.size == 0x00){
        return (wstring)"No Mesh Path Linked!";
    } else{
        return input.path;
    }
}

void Write_Mesh_Path(mesh_path &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(input.size) DeleteBytes(input.pos, input.size);
    InsertBytes(input.pos, size, 0x00);
    WriteWString(input.pos, (wstring)s);
    input.size = (Strlen(s) + 1) * 2;
}

typedef struct{
    uint32 size <name="MDF Path Size">;
    local uint64 pos <hidden=true> = FTell();
    if(size == 0x02){
        wchar_t path[1] <bgcolor=0xABA8FF, name="MDF Path">;
    } else if(size > 0x02){
        wchar_t path[size/2] <bgcolor=0x66FFFF, name="MDF Path", open=suppress>;
    }
} mdf_path <read=Read_MDF_Path, write=Write_MDF_Path, open=suppress>;

wstring Read_MDF_Path(mdf_path &input){
    if(input.size == 0x02 || input.size == 0x00){
        return (wstring)"No MDF Path Linked!";
    } else{
        return input.path;
    }
}

void Write_MDF_Path(mdf_path &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(input.size) DeleteBytes(input.pos, input.size);
    InsertBytes(input.pos, size, 0x00);
    WriteWString(input.pos, (wstring)s);
    input.size = (Strlen(s) + 1) * 2;
}


typedef struct (uint64 pathSizePosMain){
	local uint64 posPath <hidden=true> = FTell();
	local uint64 pathSizePos <hidden=true> = pathSizePosMain;
	wstring path <bgcolor=0xFFC79F, name="Texture Path">;
}multi_tex_path <read=Multi_Tex_Path_Read, write=Multi_Tex_Path_Write, name="Texture Path", open=suppress>;

string Multi_Tex_Path_Read( multi_tex_path &input ){
    return input.path;
}
void Multi_Tex_Path_Write( multi_tex_path &input, string s){
	local uint32 sizeDif = 0;
	local uint32 pathSize = ReadUInt(input.pathSizePos);
	if(sizeof(input.path) > sizeof(s) * 2){
		sizeDif = sizeof(input.path) - sizeof(s) * 2;
		DeleteBytes(input.posPath, sizeDif);
		input.path = s;
		WriteUInt(input.pathSizePos, pathSize - sizeDif);
	}else if(sizeof(input.path) < sizeof(s) * 2){
		sizeDif =  sizeof(s) * 2 - sizeof(input.path);
		InsertBytes(input.posPath, sizeDif, 0);
		WriteWString(input.posPath, (wstring)s);
		WriteUInt(input.pathSizePos, pathSize + sizeDif);
	}
	else{
		WriteWString(input.posPath, (wstring)s);
	}
}

typedef struct{
    uint32 size <name="Texture Path Size">;
    local uint64 pos <hidden=true> = FTell();
	local uint64 posTemp <hidden=true> = 0;
    if(size == 0x02){
        wchar_t path[1] <bgcolor=0xABA8FF, name="Texture Path">;
    } else if(size > 0x02){
		do{
			multi_tex_path path(pos - 4);
			posTemp = FTell();
		}while(posTemp - pos < size);
    }
} tex_path;



typedef struct{
    uint32 size <name="Path Size">;
    local uint64 pos <hidden=true> = FTell();
    if(size == 0x02){
        wchar_t path[1] <bgcolor=0xABA8FF, name="Path">;
    } else if(size > 0x02){
        wchar_t path[size/2] <bgcolor=0xFFBB66, name="Path", open=suppress>;
    }
} basic_path <read=Read_Basic_Path, write=Write_Basic_Path, open=suppress>;

wstring Read_Basic_Path(basic_path &input){
    if(input.size == 0x02 || input.size == 0x00){
        return (wstring)"No Path Linked!";
    } else{
        return input.path;
    }
}

void Write_Basic_Path(basic_path &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(input.size) DeleteBytes(input.pos, input.size);
    InsertBytes(input.pos, size, 0x00);
    WriteWString(input.pos, (wstring)s);
    input.size = (Strlen(s) + 1) * 2;
}



typedef struct (uint64 pthSPos, byte pathSizeMultiplier, byte padding)
    {
	local uint32 pathSize <hidden=true> = ReadUInt(pthSPos);
	local uint64 pathSizePos <hidden=true> = pthSPos;
	local uint64 pathPos <hidden=true> = FTell();
	local byte psm <hidden=true> = pathSizeMultiplier;
	local byte pd <hidden=true> = padding;
	
    if(pathSize < 3 && pd == 1){
        wstring path <bgcolor=0xABA8FF, name="Path", open=suppress>;
    } else if(pathSize > 0x00){
        wstring path <name="Path", open=suppress>;
    }
} loose_path <read=Read_Loose_Path, write=Write_Loose_Path, open=suppress>;

wstring Read_Loose_Path(loose_path &input){
    if(input.pathSize < 3){
        return (wstring)"No Path Linked!";
    } else{
        return input.path;
    }
}

void Write_Loose_Path(loose_path &input, string s){
	local byte temp = 2;
	if(input.psm == 1) temp = 1;
	local uint32 ogSize = (Strlen(input.path) + 1) * temp;
    local uint32 size = (Strlen(s) + 1) * temp;
	local uint32 diff = 0;
	temp = 1;
	if(input.psm == 1) temp = 2;
	local byte tempPad = 0;
	if(input.pd == 0) tempPad = 1;
	if(ogSize > size){
		diff = ogSize - size;
		DeleteBytes(input.pathPos, (diff + tempPad) * temp);
		if(Strlen(s) > 0) WriteWString(input.pathPos, (wstring)s);
		WriteUInt(input.pathSizePos, input.pathSize - (diff + tempPad));
	} else if(ogSize < size){
		diff = size - ogSize;
		InsertBytes(input.pathPos, diff * temp, 0);
		WriteWString(input.pathPos, (wstring)s);
		WriteUInt(input.pathSizePos, input.pathSize + diff);
	} else{
		WriteWString(input.pathPos, (wstring)s);
	}
}













typedef struct{
    uint32  size <name="Mesh Path Size">;
    local uint64 bakPos <hidden=true> = FTell();
    local uint64 pos <hidden=true> = FTell() + 8 + overriddenHashCount * 28;
    FSeek(pos);
    if(size) wchar_t path[size] <name="Mesh Path", bgcolor=0x99FF99, open=suppress>; else local wstring path <hidden=true> = "No Path Linked!";
    FSeek(bakPos);
} mdf_mesh_t <read=Read_MDF_Mesh, write=Write_MDF_Mesh, open=suppress>;

wstring Read_MDF_Mesh(mdf_mesh_t &input){
    return input.path;
}

void Write_MDF_Mesh(mdf_mesh_t &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(!Strlen(s)) size = 0;
    local uint32 bSize = input.size;
    if(bSize) DeleteBytes(input.pos, input.size * 2);
    if(size) InsertBytes(input.pos, size, 0x00);
    if(size) WriteWString(input.pos, (wstring)s);
    if(size) input.size = Strlen(s) + 1; else input.size = 0;
    if(!bSize)input.path = s;
}

typedef struct{
    uint32  size <name="MDF Path Size">;
    local uint64 bakPos <hidden=true> = FTell();
    local uint64 pos <hidden=true> = FTell() + 4 + overriddenHashCount * 28 + mesh.size * 2;
    FSeek(pos);
    if(size) wchar_t path[size] <name="MDF Path", bgcolor=0x66FFFF, open=suppress>; else local wstring path <hidden=true> = "No Path Linked!";
    FSeek(bakPos);
} mdf_mdf_t <read=Read_MDF_MDF, write=Write_MDF_MDF, open=suppress>;

wstring Read_MDF_MDF(mdf_mdf_t &input){
    return input.path;
}

void Write_MDF_MDF(mdf_mdf_t &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(!Strlen(s)) size = 0;
    local uint32 bSize = input.size;
    if(bSize) DeleteBytes(input.pos, input.size * 2);
    if(size) InsertBytes(input.pos, size, 0x00);
    if(size) WriteWString(input.pos, (wstring)s);
    if(size) input.size = Strlen(s) + 1; else input.size = 0;
    if(!bSize)input.path = s;
}

typedef struct{
    uint32  size <name="Tex Path Size">;
    local uint64 bakPos <hidden=true> = FTell();
    local uint64 pos <hidden=true> = FTell() + overriddenHashCount * 28 + mesh.size * 2 + mdf.size * 2;
    FSeek(pos);
    if(size) wchar_t path[size] <name="TEX Path", bgcolor=0xFFC79F, open=suppress>; else local wstring path <hidden=true> = "No Path Linked!";
    FSeek(bakPos);
} mdf_tex_t <read=Read_MDF_TEX, write=Write_MDF_TEX, open=suppress>;

wstring Read_MDF_TEX(mdf_tex_t &input){
    return input.path;
}

void Write_MDF_TEX(mdf_tex_t &input, string s){
    local uint32 size = (Strlen(s) + 1) * 2;
    if(!Strlen(s)) size = 0;
    local uint32 bSize = input.size;
    if(bSize) DeleteBytes(input.pos, input.size * 2);
    if(size) InsertBytes(input.pos, size, 0x00);
    if(size) WriteWString(input.pos, (wstring)s);
    if(size) input.size = Strlen(s) + 1; else input.size = 0;
    if(!bSize)input.path = s;
}

string property_name(struct parameter_struct &fltStruct){
    return mdf_hash_decode(fltStruct.prop_hash);
}

typedef enum <UINT32> {
    LOOP = 0xFFFFFFFF,
    NOT_LOOP = 0x00000002
} Cycle_Loop;

typedef enum <UINT32> {
    starting_frame_only = 0,
	looped_animation = 1,
	animate_once = 2,
	animate_once_freeze_on_last_frame = 3,
	
	starting_frame_only_flipped_vertically = 4,
	looped_animation_flipped_vertically = 5,
	animate_once_flipped_vertically = 6,
	animate_once_freeze_on_last_frame_flipped_vertically = 7,
	
	starting_frame_only_random_flipped_vertically = 8,
	looped_animation_random_flipped_vertically = 9,
	animate_once_random_flipped_vertically = 10,
	animate_once_freeze_on_last_frame_random_flipped_vertically = 11,
	
	starting_frame_only_dup = 12,
	looped_animation_dup = 13,
	animate_once_dup = 14,
	animate_once_freeze_on_last_frame_dup = 15,
	
	starting_frame_only_flipped_horizontally = 16,
	looped_animation_flipped_horizontally = 17,
	animate_once_flipped_horizontally = 18,
	animate_once_freeze_on_last_frame_flipped_horizontally = 19,
	
	starting_frame_only_rotated_180 = 20,
	looped_animation_rotated_180 = 21,
	animate_once_rotated_180 = 22,
	animate_once_freeze_on_last_frame_rotated_180 = 23,
	
	starting_frame_only_random_rotated_180 = 24,
	looped_animation_random_rotated_180 = 25,
	animate_once_random_rotated_180 = 26,
	animate_once_freeze_on_last_frame_random_rotated_180 = 27,
	
	starting_frame_only_flipped_horizontally_dup = 16,
	looped_animation_flipped_horizontally_dup = 17,
	animate_once_flipped_horizontally_dup = 18,
	animate_once_freeze_on_last_frame_flipped_horizontally_dup = 19,
	
	starting_frame_only_random_flipped_horizontally = 32,
	looped_animation_random_flipped_horizontally = 33,
	animate_once_random_flipped_horizontally = 34,
	animate_once_freeze_on_last_frame_random_flipped_horizontally = 35,
	
	starting_frame_only_flipped_vertically_random_flipped_horizontally = 36,
	looped_animation_flipped_vertically_random_flipped_horizontally = 37,
	animate_once_flipped_vertically_random_flipped_horizontally = 38,
	animate_once_freeze_on_last_frame_flipped_vertically_random_flipped_horizontally = 39
} Animation_Mode <read=Name_AnimationMode>;

string Name_AnimationMode(Animation_Mode& t){
    switch(t){
    case 0:
        return "First Frame Only";
        break;
    
    case 1:
        return "Looped Animation";
        break;
    
    case 2:
        return "Do The Animation Once And Disappear";
        break;
    
    case 3:
        return "Do The Animation Once And Freeze On Last Frame";
        break;
    
    case 4:
        return "First Frame Only - Flipped Vertically";
        break;
    
    case 5:
        return "Looped Animation - Flipped Vertically";
        break;
    
    case 6:
        return "Do The Animation Once And Disappear - Flipped Vertically";
        break;
    
    case 7:
        return "Do The Animation Once And Freeze On Last Frame - Flipped Vertically";
        break;
    
    case 8:
        return "First Frame Only - Randomized Flipped Vertically";
        break;
    
    case 9:
        return "Looped Animation - Randomized Flipped Vertically";
        break;
    
    case 10:
        return "Do The Animation Once And Disappear - Randomize Flipped Vertically";
        break;
    
    case 11:
        return "Do The Animation Once And Freeze On Last Frame - Randomized Flipped Vertically";
        break;
    
    case 12:
        return "First Frame Only";
        break;
    
    case 13:
        return "Looped Animation";
        break;
    
    case 14:
        return "Do The Animation Once And Disappear";
        break;
    
    case 15:
        return "Do The Animation Once And Freeze On Last Frame";
        break;
    
    case 16:
        return "First Frame Only - Flipped Horizontally";
        break;
    
    case 17:
        return "Looped Animation - Flipped Horizontally";
        break;
    
    case 18:
        return "Do The Animation Once And Disappear - Flipped Horizontally";
        break;
    
    case 19:
        return "Do The Animation Once And Freeze On Last Frame - Flipped Horizontally";
        break;
    
    case 20:
        return "First Frame Only - Rotated 180 Degrees";
        break;
    
    case 21:
        return "Looped Animation - Rotated 180 Degrees";
        break;
    
    case 22:
        return "Do The Animation Once And Disappear - Rotated 180 Degrees";
        break;
    
    case 23:
        return "Do The Animation Once And Freeze On Last Frame - Rotated 180 Degrees";
        break;
    
    case 24:
        return "First Frame Only - Flipped Horizontally - Randomized Flipped Vertically";
        break;
    
    case 25:
        return "Looped Animation - Flipped Horizontally - Randomized Flipped Vertically";
        break;
    
    case 26:
        return "Do The Animation Once And Disappear - Flipped Horizontally - Randomized Flipped Vertically";
        break;
    
    case 27:
        return "Do The Animation Once And Freeze On Last Frame - Flipped Horizontally - Randomized Flipped Vertically";
        break;
    
    case 28:
        return "First Frame Only - Flipped Horizontally";
        break;
    
    case 29:
        return "Looped Animation - Flipped Horizontally";
        break;
    
    case 30:
        return "Do The Animation Once And Disappear - Flipped Horizontally";
        break;
    
    case 31:
        return "Do The Animation Once And Freeze On Last Frame - Flipped Horizontally";
        break;
    
    case 32:
        return "First Frame Only - Randomized Flipped Horizontally";
        break;
    
    case 33:
        return "Looped Animation - Randomized Flipped Horizontally";
        break;
    
    case 34:
        return "Do The Animation Once And Disappear - Randomized Flipped Horizontally";
        break;
    
    case 35:
        return "Do The Animation Once And Freeze On Last Frame - Randomized Flipped Horizontally";
        break;
    
    case 36:
        return "First Frame Only - Flipped Vertically - Randomized Flipped Horizontally";
        break;
    
    case 37:
        return "Looped Animation - Flipped Vertically - Randomized Flipped Horizontally";
        break;
    
    case 38:
        return "Do The Animation Once And Disappear - Flipped Vertically - Randomized Flipped Horizontally";
        break;
    
    case 39:
        return "Do The Animation Once And Freeze On Last Frame - Flipped Vertically - Randomized Flipped Horizontally";
        break;
    //there's more
    default:
        local string ret;
        SPrintf(ret,"%u" ,t);
        return ret;
        break;
    }
}

typedef enum <UINT32> {
    starting_frame_only_mesh = 0,
	looped_animation_mesh = 1,
	animate_once_mesh = 2,
	animate_once_freeze_on_last_frame_mesh = 3
} Animation_Mode_Mesh <read=Name_AnimationModeMesh>;

string Name_AnimationModeMesh(Animation_Mode_Mesh& t){
    switch(t){
    case 0:
        return "First Frame Only";
        break;
    
    case 1:
        return "Looped Animation";
        break;
    
    case 2:
        return "Do The Animation Once And Disappear";
        break;
    
    case 3:
        return "Do The Animation Once And Freeze On Last Frame";
        break;
    
    //there's more
    default:
        local string ret;
        SPrintf(ret,"%u" ,t);
        return ret;
        break;
    }
}

typedef struct {
    int s;
    int r;
} RangeI;


void HeaderKind(EffectGraphType typeId){
	switch (typeId) {
	
		case ItemType_0x01_001:
            uint32 ukn[11];
			break;
		
		case ItemType_0x02_002:
            uint32 ukn1[24];
            basic_path vsdfPath <name="vsdf Path">;
			break;
			
		case ItemType_0x04_004:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			break;
			
		case ItemType_0x08_008:
            uint32 ukn1[7];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_Transform3D:
            uint32 ukn;
			float xPos <name="Position X">;
			float yPos <name="Position Y">;
			float zPos <name="Position Z">;
			float xRot <name="Rotation X">;
			float yRot <name="Rotation Y">;
			float zRot <name="Rotation Z">;
			float xScale <name="Scale X">;
			float yScale <name="Scale Y">;
			float zScale <name="Scale Z">;
			uint32 ukn;
			break;
			
		case ItemType_0x0A_010:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			break;
			
		case ItemType_0x0B_011:
			uint32 ukn1[8];
            float ukn2[48];
			break;
			
		case ItemType_0x0C_012:
            uint32 ukn1[8];
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
            uint32 ukn5[(ukn2 + ukn3 + ukn4) / 4];
			break;
			
		case ItemType_0x0D_013:
            uint32 ukn1[11];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
		
		case ItemType_ParentOptions:
            uint32 ukn1;
			uint32 positionX <name="Position X">;
			uint32 positionY <name="Position Y">;
			uint32 positionZ <name="Position Z">;
			uint32 rotationX <name="Rotation X">;
			uint32 rotationY <name="Rotation Y">;
			uint32 rotationZ <name="Rotation Z">;
			uint32 scaleX <name="Scale X">;
			uint32 scaleY <name="Scale Y">;
			uint32 scaleZ <name="Scale Z">;
			ubyte followBone <name="Follow Bone">;
			float ukn2;
			uint32 ukn3[6];
            bone_t bone <name="Bone">;
			break;
			
		case ItemType_0x0F_015:
            uint32 ukn1[9];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
		
		case ItemType_Spawn:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
			uint32 ukn5;
			uint32 ukn6;
			uint32 ukn7;
			ubyte ukn8;
			uint32 ukn9;
			uint32 ukn10;
			uint32 ukn11;
			uint32 ukn12;
			uint32 ukn13;
			uint32 ukn14;
			ubyte ukn15[3];
			float ukn16;
			ubyte ukn17[27];
			break;
			
		case ItemType_0x11_017:
            uint32 ukn1[9];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x12_018:
			uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			spos[i] = FTell();
            i++;
            small_cc small_color;
			break;
			
		case ItemType_0x13_019:
            uint32 ukn1[8];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize1){
                uint32 ukn2[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
			if(0 < subSize3){
                uint32 ukn4[subSize3 / 4] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x15_021:
            uint32 ukn1;
			uint32 ukn2;
			break;
			
		case ItemType_0x16_022:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2[12];
			break;
			
		case ItemType_0x17_023:
            uint32 ukn1[15];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_TypeBillboard3D:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[3];
			float rotation <name="Rotation">;
			float rotationRange <name="Rotation Range">;
			float scaleMultiplier <name="Scale Multiplier">;
			float scaleMultiplierRange <name="Scale Multiplier Range">;
			float scaleX <name="Scale X">;
			float scaleXRange <name="Scale X Range">;
			float scaleY <name="Scale Y">;
			float scaleYRange <name="Scale Y Range">;
			float ukn3[4];
			break;
			
		case ItemType_0x19_025:
            uint32 ukn1[15];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x1A_026:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[10];
			uint32 subCount <name="Sub Struct Count">;
			uint32 ukn3[4];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
			case ItemType_0x1B_027:
            uint32 ukn1[8];
            uint32 subSize1 <name="Sub Struct Size 1">;
			uint32 subSize2 <name="Sub Struct Size 2">;
			uint32 ukn2;
			uint32 subSize3 <name="Sub Struct Size 3">;
			uint32 subSize4 <name="Sub Struct Size 4">;
            if(0 < subSize1){
                uint32 ukn3[subSize1 / 4] <name="Sub Struct 1">;
            }
			if(0 < subSize2){
                uint32 ukn4[subSize2 / 4] <name="Sub Struct 2">;
            }
			if(0 < subSize3){
                uint32 ukn5[subSize3 * 4] <name="Sub Struct 3">;
            }
			if(0 < subSize4){
                uint32 ukn6[subSize4] <name="Sub Struct 4">;
            }
			break;
			
			case ItemType_0x1C_028:
            uint32 ukn1[14];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 ukn2;
			uint32 ukn3;
			if(0 < subSize1){
                uint32 ukn5[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize2){
                uint32 ukn6[subSize2 / 4] <name="Sub Struct2">;
            }
            if(0 < subSize3){
                uint32 ukn7[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_TypeMesh:
            uint32 ukn1[3];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn3[2];
			uint32 frameCount <name="Frame Count">;
			uint32 startingFrameMin <name="Starting Frame Min">;
			uint32 startingFrameMax <name="Starting Frame Max">;
			float animationSpeedMin <name="Animation Speed Min">;
			float animationSpeedMax <name="Animation Speed Max">;
			float acceleration <name="Acceleration">;
            float accelerationRange <name="Acceleration Range">;
			Animation_Mode_Mesh mode <name="Animation Mode">;
			uint32 ukn4[2];
			float rotationX <name="Rotation X">;
            float rotationXRange <name="Rotation X Range">;
            float rotationY <name="Rotation Y">;
            float rotationYRange <name="Rotation Y Range">;
            float rotationZ <name="Rotation Z">;
            float rotationZRange <name="Rotation Z Range">;
            float scaleX <name="Scale X">;
            float scaleXRange <name="Scale X Range">;
            float scaleY <name="Scale Y">;
            float scaleYRange <name="Scale Y Range">;
            float scaleZ <name="Scale Z">;
            float scaleZRange <name="Scale Z Range">;
            float scaleMultiplier <name="Scale Multiplier">;
            float scaleMultiplierRange <name="Scale Multiplier Range">;
			uint32 ukn5[6];
			mesh_path mesh1Path1 <name="Mesh 1 Path">;
			mesh_path mesh1Path2 <name="Mesh 2 Path">;
			mdf_path mdfPath <name="MDF Path">;
			uint32 subSize1 <name="MDF Parameters Struct Size">;
			if(subSize1 > 0){
				struct {
					for (e = 0; e < subSize1 / 32; e++){
						struct parameter_struct2{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			
			
			
			//if(0 < subSize1){
            //    ubyte ukn2[subSize1] <name="Sub Struct">;
            //}
			tex_path mskPath <name="MSK Path">;
			break;
			
		case ItemType_0x1E_030:
            uint32 ukn1[8];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			uint32 subCount4 <name="Sub Struct4 Count">;
			uint32 subCount5 <name="Sub Struct5 Count">;
			if(0 < subSize1){
                uint32 ukn2[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
			if(0 < subSize3){
                ubyte ukn4[subSize3] <name="Sub Struct3">;
            }
			if(0 < subCount4){
                uint32 ukn5[subCount4 * 4] <name="Sub Struct4">;
            }
			if(0 < subCount5){
                uint32 ukn6[subCount5] <name="Sub Struct5">;
            }
			break;
			
		case ItemType_0x1F_031:
            uint32 ukn1[4];
			uint32 ukn2[23];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 ukn4;
			if(0 < subSize1){
                uint32 ukn5[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize2){
                uint32 ukn6[subSize2 / 4] <name="Sub Struct2">;
            }
            if(0 < subSize3){
                uint32 ukn7[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x20_032:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2;
			float ukn3;
			float ukn4;
			uint32 ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			float ukn9;
			float ukn10;
			float ukn11;
			float ukn12;
			uint32 ukn13;
			float ukn14;
			float ukn15;
			uint32 ukn16;
			uint32 ukn17;
			uint32 ukn18;
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn19[9];
			uint32 ukn20;
			break;
			
		case ItemType_0x21_033:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2;
			uint32 ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			float ukn9;
			float ukn10;
			float ukn11;
			float ukn12;
			uint32 ukn13;
			float ukn14;
			float ukn15;
			uint32 ukn16;
			float ukn17;
			float ukn18;
			uint32 ukn19;
			uint32 ukn20;
			float ukn21;
			float ukn22;
			float ukn23;
			float ukn24;
			float ukn25;
			float ukn26;
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn27[8];
			break;
			
		case ItemType_0x22_034:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[4];
			float ukn3[7];
			ubyte ukn4[4];
			float ukn5[8];
			uint32 ukn6;
			float ukn7[16];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn8[20];
			break;
			
		case ItemType_0x23_035:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[2];
			float ukn3;
			uint32 ukn4;
			float ukn5[7];
			uint32 ukn6;
			float ukn7[2];
			uint32 ukn8[3];
			float ukn9;
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn10[8];
			break;
			
		case ItemType_0x24_036:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[4];
			float ukn3[5];
			uint32 ukn4;
			float ukn5[2];
			break;
			
		case ItemType_0x25_037:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[3];
			uint32 ukn3;
			float ukn4[7];
			uint32 ukn5[7];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn8[8];
			break;
			
		case ItemType_0x26_038:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[4];
			float ukn3[7];
			uint32 ukn4;
			float ukn5[2];
			uint32 ukn6[3];
			
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn8[9];
			uint32 ukn9[3];
			uint32 subCount <name="Sub Struct Count">;
			uint32 ukn10[4];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct7{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
		case ItemType_0x27_039:
            uint32 ukn1[8];
            uint32 subSize1 <name="Sub Struct Size 1">;
			uint32 subSize2 <name="Sub Struct Size 2">;
			uint32 ukn2;
			uint32 subSize3 <name="Sub Struct Size 3">;
			uint32 subSize4 <name="Sub Struct Size 4">;
            if(0 < subSize1){
                uint32 ukn3[subSize1 / 4] <name="Sub Struct 1">;
            }
			if(0 < subSize2){
                uint32 ukn4[subSize2 / 4] <name="Sub Struct 2">;
            }
			if(0 < subSize3){
                uint32 ukn5[subSize3 * 4] <name="Sub Struct 3">;
            }
			if(0 < subSize4){
                uint32 ukn6[subSize4] <name="Sub Struct 4">;
            }
			break;
			
		case ItemType_0x28_040:
            uint32 ukn1[16];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct Size2">;
			uint32 subSize3 <name="Sub Struct Size3">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
            
			if(0 < subSize3){
                uint32 ukn5[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x29_041:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[4];
			float ukn3[7];
			uint32 ukn4;
			float ukn5[2];
			uint32 ukn6;
			float ukn7[10];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn8[9];
			uint32 ukn9;
			uint32 subCount <name="Sub Struct Count">;
			uint32 ukn10[4];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct8{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
		case ItemType_0x2B_043:
            uint32 ukn1[16];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct Size2">;
			uint32 subSize3 <name="Sub Struct Size3">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
            
			if(0 < subSize3){
                uint32 ukn5[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x2C_044:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[4];
			float ukn3[7];
			ubyte ukn4[4];
			float ukn5[8];
			uint32 ukn6;
			float ukn7[16];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn8[20];
			uint32 ukn9[2];
			uint32 subCount <name="Sub Struct Count">;
			uint32 ukn10[4];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct5{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
		case ItemType_0x2D_045:
            uint32 ukn1[8];
            uint32 subSize1 <name="Sub Struct Size 1">;
			uint32 subSize2 <name="Sub Struct Size 2">;
			uint32 ukn2;
			uint32 subSize3 <name="Sub Struct Size 3">;
			uint32 subSize4 <name="Sub Struct Size 4">;
            if(0 < subSize1){
                uint32 ukn3[subSize1 / 4] <name="Sub Struct 1">;
            }
			if(0 < subSize2){
                uint32 ukn4[subSize2 / 4] <name="Sub Struct 2">;
            }
			if(0 < subSize3){
                uint32 ukn5[subSize3 * 4] <name="Sub Struct 3">;
            }
			if(0 < subSize4){
                uint32 ukn6[subSize4] <name="Sub Struct 4">;
            }
			break;
			
		case ItemType_0x2E_046:
            uint32 ukn1[16];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct Size2">;
			uint32 subSize3 <name="Sub Struct Size3">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
            
			if(0 < subSize3){
                uint32 ukn5[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x2F_047:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[4];
			float ukn3[7];
			uint32 ukn4;
			float ukn5[2];
			uint32 ukn6[3];
			float ukn7;
			
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn8[8];
			uint32 ukn9[2];
			uint32 subCount <name="Sub Struct Count">;
			uint32 ukn10[4];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct9{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
		case ItemType_0x30_048:
            uint32 ukn1[8];
            uint32 subSize1 <name="Sub Struct Size 1">;
			uint32 subSize2 <name="Sub Struct Size 2">;
			uint32 ukn2;
			uint32 subSize3 <name="Sub Struct Size 3">;
			uint32 subSize4 <name="Sub Struct Size 4">;
            if(0 < subSize1){
                uint32 ukn3[subSize1 / 4] <name="Sub Struct 1">;
            }
			if(0 < subSize2){
                uint32 ukn4[subSize2 / 4] <name="Sub Struct 2">;
            }
			if(0 < subSize3){
                uint32 ukn5[subSize3 * 4] <name="Sub Struct 3">;
            }
			if(0 < subSize4){
                uint32 ukn6[subSize4] <name="Sub Struct 4">;
            }
			break;
			
		case ItemType_0x31_049:
            uint32 ukn1[16];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct Size2">;
			uint32 subSize3 <name="Sub Struct Size3">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
            
			if(0 < subSize3){
                uint32 ukn5[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x35_053:
            uint32 ukn1[11];
			float ukn2[6];
			uint32 ukn3[3];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn4[23];
			uint32 ukn5[11];
			float ukn6[3];
			uint32 ukn7;
			bone_t bone <name="Bone">;
			uint32 ukn8;
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn9[4];
			uint32 subCount <name="Sub Struct Count">;
			uint32 ukn10[4];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct6{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
		case ItemType_0x36_054:
            uint32 ukn1[8];
            uint32 subSize1 <name="Sub Struct Size 1">;
			uint32 subSize2 <name="Sub Struct Size 2">;
			uint32 ukn2;
			uint32 subSize3 <name="Sub Struct Size 3">;
			uint32 subSize4 <name="Sub Struct Size 4">;
            if(0 < subSize1){
                uint32 ukn3[subSize1 / 4] <name="Sub Struct 1">;
            }
			if(0 < subSize2){
                uint32 ukn4[subSize2 / 4] <name="Sub Struct 2">;
            }
			if(0 < subSize3){
                uint32 ukn5[subSize3 * 4] <name="Sub Struct 3">;
            }
			if(0 < subSize4){
                uint32 ukn6[subSize4] <name="Sub Struct 4">;
            }
			break;
			
		case ItemType_0x37_055:
            uint32 ukn1[22];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct Size2">;
			uint32 subSize3 <name="Sub Struct Size3">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
            
			if(0 < subSize3){
                uint32 ukn5[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x3B_059:
            uint32 ukn1[19];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x3C_060:
            uint32 ukn1[21];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x3D_061:
            uint32 ukn1[19];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x3E_062:
            uint32 ukn1[19];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x40_064:
            uint32 ukn1[19];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_TypePolygon:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2[3];
			uint32 ukn3[2];
			float rotaionX <name="Rotaion X">;
			float rotaionXRange <name="Rotaion X Range">;
			float rotaionY <name="Rotaion Y">;
			float rotaionYRange <name="Rotaion Y Range">;
			float rotaionZ <name="Rotaion Z">;
			float rotaionZRange <name="Rotaion Z Range">;
			float scaleMultiplier <name="Scale Multiplier">;
			float scaleMultiplierRange <name="Scale Multiplier Range">;
			float scaleX <name="Scale X">;
			float scaleXRange <name="Scale X Range">;
			float scaleY <name="Scale Y">;
			float scaleYRange <name="Scale Y Range">;
			float ukn4[3];
			uint32 ukn5;
			break;
			
		case ItemType_0x43_067:
            uint32 ukn1[21];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x44_068:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2[14];
			uint32 ukn3;
			uint32 subCount <name="Sub Struct Count">;
			uint32 ukn4[4];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct10{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
		case ItemType_0x48_072:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 ukn2[4];
			float ukn3;
			uint32 ukn4;
			float ukn5[3];
			uint32 ukn6[4];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn7;
			break;
			
		case ItemType_0x4A_074:
			uint32 ukn1;
			uint32 ukn2;
			spos[i] = FTell();
            i++;
            small_cc small_color;
			spos[i] = FTell();
            i++;
            small_cc small_color;
			uint32 ukn3;
			float ukn4;
			uint32 ukn5;
			float ukn6;
			uint32 ukn7[4];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn8;
			uint32 ukn9[6];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct3{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			break;
			
		case ItemType_0x4C_076:
            uint32 ukn1[8];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct Size2">;
			uint32 subSize3 <name="Sub Struct Size3">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
            
			if(0 < subSize3){
                uint32 ukn5[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_TypeNoDraw:
            uint32 ukn1[2];
			spos[i] = FTell();
            i++;
            small_cc small_color;
			spos[i] = FTell();
            i++;
            small_cc small_color;
			uint32 ukn2;
			float rotationX <name="Rotation X">;
            float rotationXRange <name="Rotation X Range">;
            float rotationY <name="Rotation Y">;
            float rotationYRange <name="Rotation Y Range">;
            float rotationZ <name="Rotation Z">;
            float rotationZRange <name="Rotation Z Range">;
            float scaleX <name="Scale X">;
            float scaleXRange <name="Scale X Range">;
            float scaleY <name="Scale Y">;
            float scaleYRange <name="Scale Y Range">;
            float scaleZ <name="Scale Z">;
            float scaleZRange <name="Scale Z Range">;
			break;
			
		case ItemType_0x4E_078:
            uint32 ukn1[18];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x50_080:
			uint32 ukn1[2];
			float ukn2[6];
			uint32 ukn3[2];
			float ukn4[4];
			uint32 ukn5;
			float ukn6[2];
            uint32 ukn7[2];
			break;
			
		case ItemType_0x51_081:
            uint32 ukn1[15];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x52_082:
			uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			break;
			
		case ItemType_Velocity3D:
			uint32 ukn1;
			uint32 ukn2;
			float directionXStrength <name="Direction X Strength">;
            float directionXStrengthRange <name="Direction X Strength Range">;
            float directionYStrength <name="Direction Y Strength">;
            float directionYStrengthRange <name="Direction Y Strength Range">;
            float directionZStrength <name="Direction Z Strength">;
            float directionZStrengthRange <name="Direction Z Strength Range">;
			float speed <name="Speed">;
            float speedRange <name="Speed Range">;
            float acceleration <name="Acceleration">;
            float accelerationRange <name="Acceleration Range">;
			float ukn3[8];
			uint32 ukn4;
			float gravity <name="Gravity">;
            float gravityRange <name="Gravity Range">;
            uint32 ukn5[8];
			break;
			
		case ItemType_0x54_084:
            uint32 ukn1[29];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_RotateAnim:
            uint32 ukn1;
            uint32 ukn2;
			float   rotationSpeedX <name="Rotation Speed X">;
            float   rotationSpeedXRange <name="Rotation Speed X Range">;
			float   rotationSpeedY <name="Rotation Speed Y">;
            float   rotationSpeedYRange <name="Rotation Speed Y Range">;
			float   rotationSpeedZ <name="Rotation Speed Z">;
            float   rotationSpeedZRange <name="Rotation Speed Z Range">;
			float   accelerationX <name="Acceleration X">;
            float   accelerationXRange <name="Acceleration X Range">;
			float   accelerationY <name="Acceleration Y">;
            float   accelerationYRange <name="Acceleration Y Range">;
			float   accelerationZ <name="Acceleration Z">;
            float   accelerationZRange <name="Acceleration Z Range">;
			uint32 ukn3[2];
			break;
			
		case ItemType_0x57_087:
            uint32 ukn1[14];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x58_088:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			break;
			
		case ItemType_ScaleAnim:
            uint32 ukn1;
            float overallScaleSpeed <name="Overall Scale Speed">;
            float overallScaleSpeedRange <name="Overall Scale Speed Range">;
            float overallAcceleration <name="Overall Acceleration">;
            float overallAccelerationRange <name="Overall Acceleration Range">;
            float scaleSpeedX <name="Scale Speed X">;
            float scaleSpeedXRange <name="Scale Speed X Range">;
            float accelerationX <name="Acceleration X">;
            float accelerationXRange <name="Acceleration X Range">;
            float scaleSpeedY <name="Scale Speed Y">;
            float scaleSpeedYRange <name="Scale Speed Y Range">;
            float accelerationY <name="Acceleration Y">;
            float accelerationYRange <name="Acceleration Y Range">;
            float scaleSpeedZ <name="Scale Speed Z">;
            float scaleSpeedZRange <name="Scale Speed Z Range">;
            float accelerationZ <name="Acceleration Z">;
            float accelerationZRange <name="Acceleration Z Range">;
			uint32 ukn2;
			uint32 ukn3;
			break;
			
		case ItemType_0x5A_090:
            uint32 ukn1[10];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x5B_091:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3[11];
            bone_t bone <name="Bone">;
			break;
			
		case ItemType_0x5C_092:
            uint32 ukn1[16];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_Life:
            uint32 ukn1;
            uint32 fadeInDurationMin <name="FadeInDuration Min">;
            uint32 fadeInDurationMax <name="FadeInDuration Max">;
            uint32 durationMin <name="Duration Min">;
            uint32 durationMax <name="Duration Max">;
            uint32 fadeOutDurationMin <name="FadeOutDuration Min">;
            uint32 fadeOutDurationMax <name="FadeOutDuration Max">;
            uint32 ukn2;
            uint32 ukn3;
            uint32 setInfinite <name="Set Infinite">;
			break;
			
		case ItemType_0x5E_094:
            uint32 ukn1[8];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_UVSequence:
			uint32 ukn[3];
            uint32 startingFrame1 <name="Starting Frame Min">;
            uint32 startingFrame2 <name="Starting Frame Max">;
            float animationSpeed1 <name="Animation Speed Min">;
            float animationSpeed2 <name="Animation Speed Max">;
            Animation_Mode mode <name="Texture Animation Mode">;
            uvs_t  uvs <name="UVS Path">;
			/*uint32  uvsPathSize <name="UVS Path length">;
			if(0 < uvsPathSize){
				wchar_t uvsPath[uvsPathSize] <name="UVS Path", bgcolor=0x99FF99, open=suppress>;
			}*/
			break;
			
		case ItemType_0x60_096:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			break;
			
		case ItemType_0x61_097:
            uint32 ukn1[8];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x62_098:
            uint32 ukn1[3];
			float ukn2[11];
			break;
			
		case ItemType_0x63_099:
            uint32 ukn1[3];
			spos[i] = FTell();
            i++;
            small_cc small_color;
			uint32 ukn2[38];
			spos[i] = FTell();
            i++;
            small_cc small_color;
			uint32 ukn3[38];
			spos[i] = FTell();
            i++;
            small_cc small_color;
			uint32 ukn4[37];
			uint32 uvs1PathSize <name="UVS 1 Path Size">;
			uint32 uvs2PathSize <name="UVS 2 Path Size">;
			uint32 uvs3PathSize <name="UVS 3 Path Size">;
			if(0 < uvs1PathSize){
				wchar_t uvsPath1[uvs1PathSize] <name="UVS 1 Path", bgcolor=0x99FF99, open=suppress>;
			}
			if(0 < uvs2PathSize){
				wchar_t uvsPath2[uvs2PathSize] <name="UVS 2 Path", bgcolor=0x99FF99, open=suppress>;
			}
			if(0 < uvs3PathSize){
				wchar_t uvsPath3[uvs3PathSize] <name="UVS 3 Path", bgcolor=0x99FF99, open=suppress>;
			}
			
			break;
			
		case ItemType_0x64_100:
            uint32 ukn1[119];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x65_101:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			float ukn4;
			break;
			
		case ItemType_0x66_102:
            uint32 ukn1;
			float ukn2[4];
			uint32 ukn3[3];
			float ukn4;
			break;
			
		case ItemType_0x6A_106:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			break;
			
		case ItemType_0x67_103:
            uint32 ukn1[8];
			break;
			
		case ItemType_EmitterShape3D:
			uint32 ukn1;
			float   spreadXMin <name="Spread X Minimum">;
			float   spreadXMax <name="Spread X Maximum">;
			float   spreadYMin <name="Spread Y Minimum">;
			float   spreadYMax <name="Spread Y Maximum">;
			float   spreadZMin <name="Spread Z Minimum">;
			float   spreadZMax <name="Spread Z Maximum">;
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
			uint32 ukn5;
			uint32 ukn6;
			float ukn7;
			float ukn8;
			float ukn9;
			uint32 ukn10;
			uint32 ukn11;
			byte ukn12[4];
			float ukn13;
			float ukn14;
			float ukn15;
			float ukn16;
			break;
			
		case ItemType_0x69_105:
            uint32 ukn1[11];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x6C_108:
            uint32 ukn1;
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2[3];
			break;
			
		case ItemType_0x6E_110:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3[10];
			break;
			
		case ItemType_0x6F_111:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			float ukn9;
			break;
			
		case ItemType_0x70_112:
            uint32 ukn1[10];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x71_113:
            uint32 ukn1[3];
			spos[i] = FTell();
            i++;
            small_cc small_color;
			uint32 ukn2[14];
			break;
			
		case ItemType_0x74_116:
            uint32 ukn1[5];
			float ukn2[3];
			uint32 ukn3;
			float ukn4[5];
			uint32 ukn5[2];
			float ukn6[2];
			lpos[j] = FTell();
            j++;
            large_cc largel_color;
			float ukn7[6];
			uint32 ukn8[3];
			float ukn9[7];
			uint32 ukn10;
			float ukn11[6];
			uint32 ukn12[6];
			float ukn13[2];
			uint32 ukn14;
			uint32 ukn15[2];
			float ukn16[3];
			uint32 ukn17;
			bone_t bone <name="Bone">;
			uint32 ukn18;
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn19[3];
			break;
			
		case ItemType_0x75_117:
            uint32 ukn1[25];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x76_118:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2[3];
			ubyte ukn3[4];
			float ukn4[7];
			uint32 ukn5[5];
			float ukn6[32];
			uint32 ukn8[2];
			float ukn9[15];
			uint32 ukn10[3];
			float ukn11[2];
			uint32 ukn12[2];
			float ukn13[2];
			bone_t bone <name="Bone">;
			//ubyte uk3[6];
			break;
			
		case ItemType_0x77_119:
            uint32 ukn1[51];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x78_120:
            uint32 ukn1;
			ubyte ukn2[4];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn3[5];
			uint32 ukn4[5];
			float ukn5[32];
			uint32 ukn6[2];
			float ukn7[15];
			uint32 ukn8[3];
			float ukn9[2];
			uint32 ukn10[2];
			float ukn11[2];
			uint32 ukn12[6];
			mdf_path mdfPath <name="MDF Path">;
			basic_path mmtrPath <name="MMTR Path">;
			uint32 subSize <name="Sub Struct Size">;
			if(subSize > 0){
				struct {
					for (e = 0; e < subSize / 32; e++){
						struct parameter_struct4{
						uint32 prop_hash <name="UTF-16 Name Hash">;
						uint32 ukn1;
						ushort parameterCount <name="Parameter Count">;
						ushort fltsSecondCount <name="Second Count">;
						uint32 ukn2;
						
						//float parameter[parameterCount] <name="Parameter">;
						//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						
						local uint64 pos <hidden=true> = FTell();
						FSeek(pos + 12);
						float checkFloat;
						if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
							FSeek(pos);
							fpos[p] = FTell();
							p++;
							float_cc float_RGB;
						}else{
							FSeek(pos);
							float parameter[parameterCount] <name="Parameter">;
							if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
						}
							
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path texPath <name="Texture Path">;
			bone_t bone <name="Bone Maybe?">;
			break;
			
		case ItemType_0x79_121:
            uint32 ukn1[9];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			uint32 subSize2 <name="Sub Struct Size2">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 * 2] <name="Sub Struct2">;
            }
            if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn5[subSize2 * 4] <name="Sub Struct3">;
            }
			if(0 < subSize2){
                uint32 ukn6[subSize2] <name="Sub Struct4">;
            }
			break;
			
		case ItemType_0x7A_122:
            uint32 ukn1[45];
            uint32 subSize1 <name="Sub Struct Size1">;
			uint32 ukn2[2];
			if(0 < subSize1){
                uint32 ukn4[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct Size2">;
			uint32 subSize3 <name="Sub Struct Size3">;
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
            
			if(0 < subSize3){
                uint32 ukn5[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_ShaderSettings:
            uint32 ukn1;
			float ukn2;
			uint32 ukn3;
			float ukn4;
			uint32 ukn5;
			float ukn6;
			byte ukn7[4];
			byte ukn8[4] <name="Color?">;
			float ukn9;
			float ukn10;
			float ukn11;
			float ukn12;
			float ukn13;
			float ukn14;
			uint32 ukn15;
			uint32 ukn16;
			uint32 ukn17;
			float ukn18;
			float ukn19;
			float ukn20;
			float ukn21;
			float ukn22;
			float ukn23;
			uint32 ukn24;
			float ukn25;
			float ukn26;
			float ukn27;
			float ukn28;
			uint32 ukn29;
			uint32 ukn30;
			float ukn31;
			float ukn32;
			float ukn33;
			float ukn34;
			float ukn35;
            uint32 ukn36[8];
			break;
			
		case ItemType_0x7F_127:
            uint32 ukn1[14];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x80_128:
            uint32 ukn[2];
			float ukn2;
			float ukn3;
			float ukn4;
			small_cc small_color;
			float ukn5;
			byte ukn6;
			break;
			
		case ItemType_0x81_129:
            uint32 ukn1[7];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x85_133:
            uint32 ukn[12];
			break;
			
		case ItemType_0x86_134:
            uint32 ukn1[13];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x87_135:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
			break;
			
		case ItemType_PtBehavior:
            uint32 ukn[2];
			uint32 scrSize <name="Script Size">;
			uint32 varCount <name="Script Variable Count">;
			char   str[scrSize] <name="Script", bgcolor=0xFFFFAA, open=suppress>;
			for (e = 0; e < varCount; e++){
			    struct{
				    uint32 varSize <name="Variable Size">;
                    uint32 varID <name="Variable Type ID">;
                    if(varID == 0x0F){
                        ubyte ukn[12];
                        spos[i] = FTell();
                        i++;
                        small_cc small_color;
                        char var[varSize-20] <name="Variable", bgcolor=0xA3BECC, open=suppress>;
                    }else{
                        ubyte ukn[12];
				        char  variable[varSize-16] <name="Vairable", bgcolor=0xD6D6D6, open=suppress>;
                    }
			    } variable <name="Script Variable">;
			}
			break;
			
		case ItemType_0x8B_139:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			break;
			
		case ItemType_0x8D_141:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			break;
			
		case ItemType_0x8E_142:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			break;
			
		case ItemType_0x8F_143:
            uint32 ukn1[6];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x90_144:
            uint32 ukn1;
			float ukn2;
			uint32 ukn3;
			uint32 ukn4;
			float ukn5;
			break;
			
		case ItemType_0x92_146:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3[11];
			uint32 ukn4[4];
			break;
			
		case ItemType_0x93_147:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			float ukn4;
			uint32 ukn5;
			float ukn6;
			break;
			
		case ItemType_0x94_148:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
			uint32 ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			break;
			
		case ItemType_0x95_149:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			break;
			
		case ItemType_0x96_150:
            uint32 ukn[63];
			break;
			
		case ItemType_0x98_152:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			float ukn4;
			float ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			float ukn9;
			float ukn10;
			float ukn11;
			float ukn12;
			float ukn13;
			float ukn14;
			break;
			
		case ItemType_0x9A_154:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
			uint32 ukn5;
			break;
			
		case ItemType_0x9B_155:
            uint32 ukn1;
			ubyte ukn2[4];
			uint32 ukn3[4];
			float ukn4[4];
			uint32 ukn5[4];
			float ukn6[6];
			uint32 ukn7[6];
			float ukn8[8];
			uint32 ukn9[4];
			float ukn10[7];
			uint32 ukn11[6];
			float ukn12[6];
			uint32 ukn13[3];
			float ukn14;
			uint32 ukn15;
			uint32 colorCodeCount <name="Color Code Count">;
			uint32 subSizeCount <name="Sub Size Count">;
			
			local uint64 uvsPos1 <hidden=true> = FTell();
			uint32 uvsPathSize1 <name="UVS Path Size">;
			local uint64 pathPos <hidden=true> = FTell();
			uint32 meshPathSize <name="Path Size">;
			local uint64 texPos3 <hidden=true> = FTell();
			uint32 texPathSize3 <name="TEX Path Size">;
			local uint64 uvsPos4 <hidden=true> = FTell();
			uint32 uvsPathSize4 <name="UVS Path Size">;
			local uint64 pathPos5 <hidden=true> = FTell();
			uint32 texPathSize5 <name="Path Size">;
			
			
			loose_path uvsPath1(uvsPos1, 0, 1) <bgcolor=0xFFC79F, name="UVS Path">;
			loose_path uknPath1(pathPos, 0, 1) <bgcolor=0xFFC79F, name="Path">;
			loose_path texPath(texPos3, 0, 1) <bgcolor=0xFFC79F, name="TEX Path">;
			loose_path uvsPath2(uvsPos4, 0, 1) <bgcolor=0xFFC79F, name="UVS Path">;
			loose_path uknPath2(pathPos5, 0, 1) <bgcolor=0xFFC79F, name="Path">;
			if(0 < subSizeCount){
                ubyte ukn16[subSizeCount] <name="Sub Struct">;
            }
			if(0 < colorCodeCount){
				for (e = 0; e < colorCodeCount; e++){
					float ukn17;
					spos[i] = FTell();
					i++;
					small_cc small_color;
				}
            }
			break;
			
		case ItemType_0x9E_158:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			uint32 ukn4;
			uint32 ukn5;
			uint32 ukn6;
			uint32 ukn7;
			float ukn8;
			float ukn9;
			float ukn10;
			break;
			
		case ItemType_0x9F_159:
            uint32 ukn1[8];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize1){
                uint32 ukn2[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
			if(0 < subSize3){
                uint32 ukn4[subSize3 / 4] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0xA0_160:
            uint32 ukn1[11];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xA1_161:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
			float ukn5;
			float ukn6;
			break;
			
		case ItemType_0xA3_163:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			break;
			
		case ItemType_0xA4_164:
            uint32 ukn1[8];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize1){
                uint32 ukn2[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
			if(0 < subSize3){
                uint32 ukn4[subSize3 / 4] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0xA5_165:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			float ukn4;
			break;
			
		case ItemType_0xA7_167:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3;
			float ukn4;
			uint32 ukn5;
			uint32 ukn6;
			uint32 ukn7;
			uint32 ukn8;
			if(ukn2 == 13){
				bone_t bone <name="Bone">;
			}
			break;
			
		case ItemType_0xA8_168:
            uint32 ukn1;
			ubyte ukn2[4];
			float ukn3;
			float ukn4;
			uint32 ukn5;
			uint32 ukn6;
			float ukn7;
			float ukn8;
			float ukn9;
			float ukn10;
			uint32 ukn11;
			float ukn13;
			float ukn14;
			float ukn15;
			float ukn16;
			uint32 ukn17;
			uint32 ukn18;
			uint32 ukn19;
			if(ukn2[0] == 81){
				bone_t bone <name="Bone">;
			}
			break;
			
		case ItemType_PtColor:
            uint32 ukn[3];
            spos[i] = FTell();
            i++;
            small_cc small_color;
			break;
			
		case ItemType_PtColorClip:
            uint32 ukn1;
            uint32 secChunkID <name="Second Chunk Type ID">;
            uint32 ukn2;
            Cycle_Loop loop <name="Loop State", format=hex, bgcolor=0x99CCFF>;
            float  loopTime <name="Loop Duration", bgcolor=0xFF9BDE>;
            uint32 ukn3[3];
            uint32 firstChunkSize <name="First Chunk Size">;
            uint32 secondChunkSize <name="Second Chunk Size">;
            uint32 thirdChunkSize <name="Third Chunk Size">;
            backPos = FTell();
            if(0 < firstChunkSize){
                struct{
                    for(e = 0; e < firstChunkSize/8; e++){
                        uint32 colorBitCount <name="Color Count">;
                        colorBitCount_arr[e] = colorBitCount;
                        uint32 intCount <name="Color INT Count">;
                        intCount_arr[e] = intCount;
                    }
                } firstChunk <name="First Chunk (Second Chunk Data)", bgcolor=0xFFBD9B>;
            }
            if(0 < secondChunkSize){
                backPoseSC = FTell();
                switch (secChunkID) {
                    case 0x0000000F:
                        struct{
							for(e = 0; e < 4; e++){
								switch(e+1){
									case 1:
										for(c5it = 0; c5it < colorBitCount_arr[e]; c5it++){
											struct{
												float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
												uint32 ukn;
												if( colorBitCount_arr[3] > c5it){
													redPos[red] = FTell();
													red++;
												} else {
													alphaLessRedPos[alphaLessRed] = FTell();
													alphaLessRed++;
												}
												ubyte red <name="Red", bgcolor=0x9B9BFF>;
												ubyte ukn2[3];
											} redSt <name="Red">;
										}
										break;
										
									case 2:
										for(c5it = 0; c5it < colorBitCount_arr[e]; c5it++){
											struct{
												float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
												uint32 ukn;
												if( colorBitCount_arr[3] > c5it){
													greenPos[green] = FTell();
													green++;
												} else {
													alphaLessGreenPos[alphaLessGreen] = FTell();
													alphaLessGreen++;
												}
												ubyte green <name="Green", bgcolor=0x67AA67>;
												ubyte ukn2[3];
											} greenSt <name="Green">;
										}
										break;
										
									case 3:
										for(c5it = 0; c5it < colorBitCount_arr[e]; c5it++){
											struct{
												float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
												uint32 ukn;
												if( colorBitCount_arr[3] > c5it){
													bluePos[blue] = FTell();
													blue++;
												} else {
													alphaLessBluePos[alphaLessBlue] = FTell();
													alphaLessBlue++;
												}
												ubyte blue <name="Blue", bgcolor=0xFF9B9B>;
												ubyte ukn2[3];
											} blueSt <name="Blue">;
										}
										break;
										
									case 4:
										for(c5it = 0; c5it < colorBitCount_arr[e]; c5it++){
											struct{
												float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
												uint32 ukn;
												alphaPos[alpha] = FTell();
												alpha++;
												ubyte alpha <name="Alpha", bgcolor=0x9BFFFF>;
												ubyte ukn2[3];
											} alphaSt <name="Alpha">;
										}
										break;
									default:
										break;
								}
							}
						}secondChunk <name="Second Chunk (Color & Alpha)">;
                        break;
                    case 0x00000008:
						for(c5it = 0; c5it < colorBitCount_arr[0]; c5it++){
							struct{
								float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
								uint32 ukn;
								onlyAlphaPos[onlyAlpha]= FTell();
								onlyAlpha++;
								ubyte alpha <name="Alpha", bgcolor=0x9BFFFF>;
								ubyte ukn2[3];
							} alphaSt <name="Alpha">;
						}
						break;
                    case 0x00000007:
                    case 0x0000000E:
                        struct{
							for(e = 0; e < 3; e++){
								switch(e+1){
									case 1:
										for(c5it = 0; c5it < colorBitCount_arr[e]; c5it++){
											struct{
												float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
												uint32 ukn;
												alphaLessRedPos[alphaLessRed] = FTell();
												alphaLessRed++;
												ubyte red <name="Red", bgcolor=0x9B9BFF>;
												ubyte ukn2[3];
											} redSt <name="Red">;
										}
										break;
										
									case 2:
										for(c5it = 0; c5it < colorBitCount_arr[e]; c5it++){
											struct{
												float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
												uint32 ukn;
												alphaLessGreenPos[alphaLessGreen] = FTell();
												alphaLessGreen++;
												ubyte green <name="Green", bgcolor=0x67AA67>;
												ubyte ukn2[3];
											} greenSt <name="Green">;
										}
										break;
										
									case 3:
										for(c5it = 0; c5it < colorBitCount_arr[e]; c5it++){
											struct{
												float appearTime <name="Appear Time", bgcolor=0xA2A2A2>;
												uint32 ukn;
												alphaLessBluePos[alphaLessBlue] = FTell();
												alphaLessBlue++;
												ubyte blue <name="Blue", bgcolor=0xFF9B9B>;
												ubyte ukn2[3];
											} blueSt <name="Blue">;
										}
										break;
										
									default:
										break;
								}
							}
						}secondChunk <name="Second Chunk (Color & Alpha)">;
						break;
                    default:
                        struct{
                            uint32 ukn[secondChunkSize/4];
                        } secondChunk <name="Second Chunk">;
                        break;
                }
            }
            if(0 < thirdChunkSize){
                struct{
                    uint32 ukn[thirdChunkSize/4];
                } thirdChunk <name="Third Chunk", bgcolor=0x9BFFF9B>;
            }
            FSeek(backPos + firstChunkSize + secondChunkSize + thirdChunkSize);
			break;
			
		case ItemType_0xAE_174:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			uint32 ukn4;
			break;
			
		case ItemType_0xAF_175:
            uint32 ukn1[9];
            uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 ukn2[2];
            if(0 < subSize1){
                uint32 ukn3[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn4[subSize2 / 4] <name="Sub Struct2">;
            }
			break;
			
		case ItemType_0xB0_176:
			uint32 ukn1;
			ubyte ukn2[4];
			float ukn3;
			uint32 ukn4[3];
			float ukn5[6];
			uint32 ukn6[8];
			float ukn7[2];
			uint32 ukn8[4];
			float ukn9;
			local uint64 texPos1 <hidden=true> = FTell();
			uint32 texPathSize1 <name="Path Size">;
			local uint64 meshPos <hidden=true> = FTell();
			uint32 meshPathSize <name="Mesh Path Size">;
			local uint64 texPos3 <hidden=true> = FTell();
			uint32 texPathSize3 <name="Path Size">;
			local uint64 texPos4 <hidden=true> = FTell();
			uint32 texPathSize4 <name="Path Size">;
			local uint64 texPos5 <hidden=true> = FTell();
			uint32 texPathSize5 <name="Path Size">;
			local uint64 texPos6 <hidden=true> = FTell();
			uint32 texPathSize6 <name="Path Size">;
			
			loose_path texPath(texPos1, 1, 1) <bgcolor=0xFFC79F, name="Path">;
			loose_path meshPath(meshPos, 1, 1) <bgcolor=0xFFC79F, name="Mesh Path">;
			loose_path texPath(texPos3, 1, 1) <bgcolor=0xFFC79F, name="Path">;
			loose_path texPath(texPos4, 1, 1) <bgcolor=0xFFC79F, name="Path">;
			loose_path texPath(texPos5, 1, 1) <bgcolor=0xFFC79F, name="Path">;
			loose_path texPath(texPos6, 1, 1) <bgcolor=0xFFC79F, name="Path">;
			break;
			
		case ItemType_0xB3_179:
			uint32 ukn1;
            uint32 ukn2;
			uint32 ukn3;
			break;
			
		case ItemType_0xB5_181:
			uint32 ukn1;
            float ukn2[16];
			uint32 ukn3[4];
			break;
			
		case ItemType_0xB6_182:
            uint32 ukn1[8];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize1){
                uint32 ukn2[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
			if(0 < subSize3){
                uint32 ukn4[subSize3 / 4] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0xB7_183:
            uint32 ukn1[22];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn3[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xBE_190:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3[12];
			break;
			
		case ItemType_0xBF_191:
			uint32 ukn1[10];
			float ukn2;
			float ukn3;
			uint32 ukn4[5];
			break;
			
		case ItemType_0xC1_193:
            uint32 ukn1;
			uint32 ukn2;
			break;
			
		case ItemType_0xC4_196:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			break;
			
		case ItemType_0xC5_197:
            uint32 ukn1;
			float ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			uint32 ukn6;
			uint32 ukn7;
			break;
			
		case ItemType_0xC6_198:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3[10];
            bone_t bone <name="Bone">;
			break;
			
		case ItemType_0xC7_199:
            uint32 ukn1[8];
            uint32 subSize1 <name="Sub Struct Size 1">;
			uint32 subSize2 <name="Sub Struct Size 2">;
			uint32 ukn2;
            if(0 < subSize1){
                uint32 ukn3[subSize1 / 4] <name="Sub Struct 1">;
            }
			if(0 < subSize2){
                uint32 ukn4[subSize2 / 4] <name="Sub Struct 2">;
            }
			break;
			
		case ItemType_0xC8_200:
            uint32 ukn1[12];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn3[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xD5_213:
            uint32 ukn1;
			break;
			
		case ItemType_0xD6_214:
            uint32 ukn[4];
			break;
			
		case ItemType_0xDA_218:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			break;
			
		case ItemType_0xDB_219:
            uint32 ukn1[3];
			float ukn2[18];
			break;
			
		case ItemType_0xDC_220:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			float ukn4;
			uint32 ukn5;
			uint32 ukn6;
			uint32 ukn7;
			float ukn8;
			float ukn9;
			break;
			
		case ItemType_0xDD_221:
            uint32 ukn1[9];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                ubyte ukn2[subSize] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xDF_223:
            uint32 ukn[16];
			break;
			
		case ItemType_0xE0_224:
            uint32 ukn1;
			uint32 ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			uint32 ukn6;
			float ukn7;
			break;
			
		case ItemType_0xE1_225:
            uint32 ukn1[8];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xE2_226:
            uint32 ukn1;
			uint32 ukn2;
			uint32 ukn3;
			float ukn4;
			uint32 subSize <name="Sub Struct Size">;
			float ukn5[15];
			if(0 < subSize){
                float ukn6[subSize * 7] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xE6_230:
            uint32 ukn1[2];
			float ukn2[18];
			break;
			
		case ItemType_0xE7_231:
            uint32 ukn1[8];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize1){
                uint32 ukn2[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
			if(0 < subSize3){
                uint32 ukn4[subSize3 / 4] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0xE8_232:
            uint32 ukn1[20];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xEF_239:
            uint32 ukn1;
			uint32 ukn2;
			mid_cc mid_color1;
			float ukn3;
			float ukn4;
			mid_cc mid_color2;
			float ukn5;
			float ukn6;
			uint32 ukn8[15];
			break;
			
		case ItemType_0xF0_240:
            uint32 ukn1[24];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xF1_241:
            uint32 ukn1;
			spos[i] = FTell();
            i++;
            small_cc small_color1;
			float ukn2;
			spos[i] = FTell();
            i++;
            small_cc small_color2;
			float ukn3;
			float ukn4;
			float ukn5;
			ubyte ukn6[87];
			break;
			
		case ItemType_0xF4_244:
			uint32 ukn1;
            ubyte ukn2[10];
            basic_path efcsvPath <name="EFCSV Path">;
			basic_path ukn2 <name="Unknown Path">;
			basic_path ukn3 <name="Unknown Path">;
			basic_path ukn4 <name="Unknown Path">;
			break;
			
		case ItemType_0xF5_245:
			uint32 ukn1[8];
            basic_path efcsvPath <name="EFCSV Path">;
			basic_path ukn2 <name="Unknown Path">;
			basic_path ukn3 <name="Unknown Path">;
			basic_path ukn4 <name="Unknown Path">;
			break;
			
		case ItemType_0xF3_243:
			uint32 ukn[11];
			break;
			
		case ItemType_0xF7_247:
			ubyte ukn[55];
			break;
			
		case ItemType_0xF9_249:
            uint32 ukn1;
			ubyte ukn2[4];
			break;
			
		case ItemType_0xFA_250:
            uint32 ukn;
			break;
			
		case ItemType_0xFC_252:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2[3];
			uint32 ukn3[2];
			float ukn4[10];
			break;
			
		case ItemType_0xFD_253:
            uint32 ukn1[16];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0xFE_254:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2;
			float ukn3;
			float ukn4;
			uint32 ukn5;
			uint32 ukn6;
			float rotaionX <name="Rotaion X">;
			float rotaionXRange <name="Rotaion X Range">;
			float rotaionY <name="Rotaion Y">;
			float rotaionYRange <name="Rotaion Y Range">;
			float rotaionZ <name="Rotaion Z">;
			float rotaionZRange <name="Rotaion Z Range">;
			float scaleMultiplier <name="Scale Multiplier">;
			float scaleMultiplierRange <name="Scale Multiplier Range">;
			float scaleX <name="Scale X">;
			float scaleXRange <name="Scale X Range">;
			float scaleY <name="Scale Y">;
			float scaleYRange <name="Scale Y Range">;
			uint32 ukn7;
			break;
			
		case ItemType_0xFF_255:
            uint32 ukn1[21];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x100_256:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2;
			float ukn3;
			float ukn4;
			float ukn5;
			uint32 ukn6;
			uint32 ukn7;
			uint32 ukn8;
			float ukn9;
			float ukn10;
			float ukn11;
			float ukn12;
			break;
			
		case ItemType_0x101_257:
            uint32 ukn1[11];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x102_258:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			float ukn2;
			float ukn3;
			float ukn4;
			uint32 ukn5;
			float ukn6;
			float ukn7;
			float ukn8;
			float ukn9;
			float ukn10;
			uint32 ukn11;
			float ukn12;
			float ukn13;
			uint32 ukn14;
			float ukn15;
			float ukn16;
			float ukn17;
			float ukn18;
			float ukn19;
			float ukn20;
			float ukn21;
			float ukn22;
			break;
			
		case ItemType_0x103_259:
            uint32 ukn1[15];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn2[subSize / 4] <name="Sub Struct">;
            }
			break;
			
		case ItemType_0x104_260:
            uint32 ukn1;
			ubyte ukn2[4];
			ubyte ukn3[4];
			ubyte ukn4[4];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 frameCount <name="Frame Count">;
			uint32 startingFrameMin <name="Starting Frame Min">;
			uint32 startingFrameMax <name="Starting Frame Max">;
			float animationSpeedMin <name="Animation Speed Min">;
			float animationSpeedMax <name="Animation Speed Max">;
			float acceleration <name="Acceleration">;
            float accelerationRange <name="Acceleration Range">;
			Animation_Mode_Mesh mode <name="Animation Mode">;
			uint32 ukn5;
			uint32 ukn6;
			float rotationX <name="Rotation X">;
            float rotationXRange <name="Rotation X Range">;
            float rotationY <name="Rotation Y">;
            float rotationYRange <name="Rotation Y Range">;
            float rotationZ <name="Rotation Z">;
            float rotationZRange <name="Rotation Z Range">;
            float scaleX <name="Scale X">;
            float scaleXRange <name="Scale X Range">;
            float scaleY <name="Scale Y">;
            float scaleYRange <name="Scale Y Range">;
            float scaleZ <name="Scale Z">;
            float scaleZRange <name="Scale Z Range">;
            float scaleMultiplier <name="Scale Multiplier">;
            float scaleMultiplierRange <name="Scale Multiplier Range">;
			uint32 ukn7;
			float ukn8;
			uint32 ukn9;
			uint32 ukn10;
			mesh_path mesh1Path1 <name="Mesh 1 Path">;
			mesh_path mesh1Path2 <name="Mesh 2 Path">;
			mdf_path mdfPath <name="MDF Path">;
			uint32 subSize1 <name="MDF Parameters Struct Size">;
			
			if(subSize1 > 0){
				struct {
					for (e = 0; e < subSize1 / 32; e++){
						struct {
							uint32 prop_hash <name="UTF-16 Name Hash">;
							uint32 ukn1;
							ushort parameterCount <name="Parameter Count">;
							ushort fltsSecondCount <name="Second Count">;
							uint32 ukn2;
							
							//float parameter[parameterCount] <name="Parameter">;
							//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
							
							local uint64 pos <hidden=true> = FTell();
							FSeek(pos + 12);
							float checkFloat;
							if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
								FSeek(pos);
								fpos[p] = FTell();
								p++;
								float_cc float_RGB;
							}else{
								FSeek(pos);
								float parameter[parameterCount] <name="Parameter">;
								if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
							}
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			tex_path mskPath <name="MSK Path">;
			break;
			
		case ItemType_0x105_261:
            uint32 ukn1[29];
			break;
			
		case ItemType_0x106_262:
            uint32 ukn1[21];
            uint32 subSize <name="Sub Struct Size">;
            if(0 < subSize){
                uint32 ukn3[subSize / 4] <name="Sub Struct">;
            }
			uint32 ukn2[3];
			break;
			
		case ItemType_0x107_263:
			uint32 ukn1[4];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			uint32 frameCount <name="Frame Count">;
			uint32 startingFrameMin <name="Starting Frame Min">;
			uint32 startingFrameMax <name="Starting Frame Max">;
			float animationSpeedMin <name="Animation Speed Min">;
			float animationSpeedMax <name="Animation Speed Max">;
			float acceleration <name="Acceleration">;
            float accelerationRange <name="Acceleration Range">;
			Animation_Mode_Mesh mode <name="Animation Mode">;
			uint32 ukn2[2];
			float rotationX <name="Rotation X">;
            float rotationXRange <name="Rotation X Range">;
            float rotationY <name="Rotation Y">;
            float rotationYRange <name="Rotation Y Range">;
            float rotationZ <name="Rotation Z">;
            float rotationZRange <name="Rotation Z Range">;
            float scaleX <name="Scale X">;
            float scaleXRange <name="Scale X Range">;
            float scaleY <name="Scale Y">;
            float scaleYRange <name="Scale Y Range">;
            float scaleZ <name="Scale Z">;
            float scaleZRange <name="Scale Z Range">;
            float scaleMultiplier <name="Scale Multiplier">;
            float scaleMultiplierRange <name="Scale Multiplier Range">;
			uint32 ukn3;
			float ukn4;
			uint32 ukn5[5];
			float ukn6;
			uint32 ukn7[3];
			float ukn8[17];
			/*
			uint32 trailLength <name="Trail Length ">;
			float ukn4;
			uint32 ukn5;
			uint32 detachFromBoneMin <name="Frames Before Detaching from Bone Min">;
			uint32 detachFromBoneMax <name="Frames Before Detaching from Bone Max">;
            float ukn6[6];
			uint32 ukn7; // Unsure if int or float
			float ukn8[12];
			*/
			mesh_path mesh1Path1 <name="Mesh 1 Path">;
			mesh_path mesh1Path2 <name="Mesh 2 Path">;
			mdf_path mdfPath <name="MDF Path">;
			uint32 subSize1 <name="MDF Parameters Struct Size">;
			
			if(subSize1 > 0){
				struct {
					for (e = 0; e < subSize1 / 32; e++){
						struct {
							uint32 prop_hash <name="UTF-16 Name Hash">;
							uint32 ukn1;
							ushort parameterCount <name="Parameter Count">;
							ushort fltsSecondCount <name="Second Count">;
							uint32 ukn2;
							
							//float parameter[parameterCount] <name="Parameter">;
							//if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
							
							local uint64 pos <hidden=true> = FTell();
							FSeek(pos + 12);
							float checkFloat;
							if(checkFloat > 0 && parameterCount == 4 && fltsSecondCount == 1){
								FSeek(pos);
								fpos[p] = FTell();
								p++;
								float_cc float_RGB;
							}else{
								FSeek(pos);
								float parameter[parameterCount] <name="Parameter">;
								if(4 - parameterCount)  float padding[4 - parameterCount] <name="Padding">;
							}
						}parameters <name="parameter">;
					}
				}mdf_parameters <name="MDF Parameters">;
			}
			
			
			
			//if(0 < subSize1){
            //    ubyte ukn3[subSize1] <name="Sub Struct">;
            //}
			tex_path mskPath <name="MSK Path">;
			break;
			
		case ItemType_0x108_264:
            uint32 ukn1[8];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			uint32 subCount4 <name="Sub Struct4 Count">;
			uint32 subCount5 <name="Sub Struct5 Count">;
			if(0 < subSize1){
                uint32 ukn2[subSize1 / 4] <name="Sub Struct1">;
            }
			if(0 < subSize2){
                uint32 ukn3[subSize2 / 4] <name="Sub Struct2">;
            }
			if(0 < subSize3){
                uint32 ukn4[subSize3 / 4] <name="Sub Struct3">;
            }
			if(0 < subCount4){
                uint32 ukn5[subCount4 * 4] <name="Sub Struct4">;
            }
			if(0 < subCount5){
                uint32 ukn6[subCount5] <name="Sub Struct5">;
            }
			break;
			
		case ItemType_0x109_265:
            uint32 ukn1[4];
			uint32 ukn2[18];
			uint32 subSize1 <name="Sub Struct1 Size">;
			uint32 ukn4;
			if(0 < subSize1){
                uint32 ukn5[subSize1 / 4] <name="Sub Struct1">;
            }
			uint32 subSize2 <name="Sub Struct2 Size">;
			uint32 subSize3 <name="Sub Struct3 Size">;
			if(0 < subSize2){
                uint32 ukn6[subSize2 / 4] <name="Sub Struct2">;
            }
            if(0 < subSize3){
                uint32 ukn7[subSize3] <name="Sub Struct3">;
            }
			break;
			
		case ItemType_0x10A_266:
            uint32 ukn1[2];
			mpos[h] = FTell();
            h++;
            mid_cc mid_color;
			int32 ukn2[2];
			float ukn3;
			ubyte ukn4[4];
			int32 ukn5[2];
			float ukn6[30];
			int32 ukn7[2];
			float ukn8[2];
			int32 ukn9;
			float ukn10[6];
			int32 ukn11[7];
			float ukn12[6];
			int32 ukn13[7];
			float ukn14[6];
			int32 ukn15[7];
			
			local uint64 bonePos1 <hidden=true> = FTell();
			uint32 boneSize1 <name="Bone 1 Size">;
			local uint64 bonePos2 <hidden=true> = FTell();
			uint32 boneSize2 <name="Bone 2 Size">;
			local uint64 bonePos3 <hidden=true> = FTell();
			uint32 boneSize3 <name="Bone 3 Size">;
			
			loose_path bone1(bonePos1, 1, 1) <bgcolor=0x99CCFF, name="Bone 1">;
			loose_path bone2(bonePos2, 1, 1) <bgcolor=0x99CCFF, name="Bone 2">;
			loose_path bone3(bonePos3, 1, 1) <bgcolor=0x99CCFF, name="Bone 3">;
			
			break;
		
		default:
			Exit(FTell()-4);
			break;

//End of the function
	}
					
}

string EFX_Block_Name(struct Extra_EFX& input){
    if(input.link){
        return "Linked EFX - ";
    } else{
        return "Embedded EFX - ";
    }
}

wstring MSK4_Name(struct MSK4& input){
    wstring name = eff_name_utf8_hash_decode(input.utf8Hash);
    if(name != "__NULL__"){
        return name;
    }else{
        return "MSK4 Header";
    }
}

wstring Modifier_Name(struct Modifier& input){
    wstring name = eff_name_utf8_hash_decode(input.utf8Hash);
    if(name != "__NULL__"){
        return name;
    }else{
        return "Modifier";
    }
}

wstring Effect_Name(struct Effect& input){
    //wstring name = eff_name_utf8_hash_decode(input.utf8Hash);
    //if(name != "__NULL__"){
        //return name;
    //}else{
        return "Effect";
    //}
}

wstring Cnd_Block_Name(struct Cnd_Block& input){
    wstring name;
    if(name != "__NULL__"){
        return name;
    }else{
        return "Condition";
    }
}

void EFXTemplate(){
	struct{
		char    magic[4] <name="File Magic", open=suppress>;
		uint32  ukn;
		uint32  effectCount <bgcolor=0xFBFFD9, name="Effect Count">;
		uint32  nameBuffSize <bgcolor=0xDCDCFF, name="Name Buffer Size">;
		uint32  efxCount <bgcolor=0xFFC1E1, name="Linked EFX Count">;
		uint32  msk4Count <bgcolor=0xFFC1C1, name="MSK4 Count">;
		uint32  modifierCount <bgcolor=0xFF99E6, name="Modifier Count">;
		uint32  cndBlockCount <bgcolor=0xFFB7FF, name="Condition Block Count">;
		uint32  cndBuffSize <bgcolor=0xA0FFFF,name="Condition Block Buffer Size">;
		uint32  boneCount <bgcolor=0xA0FFFF>;
		uint32  boneAttributeEntryCount <bgcolor=0xA0FFFF>;
		uint32  ukn3 <bgcolor=0xA0FFFF>;
	} Header <name="EFX Header">;
	
    if(Header.nameBuffSize){
	    struct{
            local uint64 bufferStart <hidden=true> = FTell();
            while(true){
                struct{
                    if(ReadStringLength(FTell()) > 2) string effName <name="Effect Name">; else if (ReadWStringLength(FTell()) > 2) wstring effName <name="Effect Name">; else if(ReadWStringLength(FTell()) == 2) wstring effName <name="Effect Name">;else string effName <name="Effect Name">;
                }bufferStr <name="String">;
	    	    //ubyte    bfr[Header.nameBuffSize] <bgcolor=0xD4FFE6, name="Buffer", open=suppress>;
                if(FTell() >= bufferStart + Header.nameBuffSize) break;
            }
            FSeek(bufferStart + Header.nameBuffSize);
	    }nameBuffer <bgcolor=0xD4FFE6, name="Name Buffer">;
    }
	
	if (Header.modifierCount > 0){
        struct{
		    for (d = 0; d < Header.modifierCount; d++){
			    struct Modifier{
                    uint32 utf16Hash <name="UTF-16 Name Hash">;
                    uint32 utf8Hash <name="UTF-8 Name Hash">;
                    float  ukn;
                    float  param <name="Parameter">;
                    float  ukn;
                    float  ukn;
			    }modifier;
		    }
        }modifiers <name="Modifiers">;
	}
	
	if(Header.boneCount){
		struct{
			for (d = 0; d < Header.boneCount; d++){
				struct{
					uint32	boneV1 <bgcolor=0xE4FFD6>;
					uint32	boneV2 <bgcolor=0xE4FFD6>;
				}boneValue <name="Bone Value">;
			}
		}boneValues <name="Bone Values">;
	}
	
	if(Header.boneAttributeEntryCount){
		struct{
			for (d = 0; d < Header.boneAttributeEntryCount; d++){
				ushort	boneAttr <bgcolor=0xF4FFC6>;
			}
		}boneAttribute <name="Bone Attribute">;
	}
	
	
	
	
	
	if (0 < Header.efxCount){
		for(f = 0; f < Header.efxCount; f++){
			struct Extra_EFX {
                local ubyte link <hidden=true> = false;
				uint32 ukn;
                uint32 utf8Hash <name="UTF-8 Hash">;
				uint32 ukn;
				uint32 ukn;
				uint32 ukn;
				local uint64 efxSizePos <hidden=true> = FTell();
				uint32 efxSize <name="Path/EFX Size">;
				local char efxID[4] <hidden=true, open=suppress>;
                ReadBytes(efxID, FTell(), 4);
				if(efxID == "efxr"){
					EFXTemplate();
				} else{
                    link = true;
					loose_path mdfPath(efxSizePos, 0, 1) <bgcolor=0xFFC1E1, name="Linked EFX Path", open=suppress>;
					//wchar_t efxPath[efxSize/2] <name="Linked EFX Path", bgcolor=0xFFC1E1, open=suppress>;
				}
			} efxHeader <name=EFX_Block_Name>;
		}
	}
	

	if (Header.msk4Count > 0){
        struct {
		    for (c = 0; c < Header.msk4Count; c++){
                struct MSK4 {
                    local uint32 msk4mod <hidden=true, format=hex> = ReadUInt(FTell() + 12);
                    uint32 ukn1;
                    uint32 utf8Hash <name="UTF-8 Name Hash">;
                    uint32 ukn2[6];
                    float  ukn3[3];
                    if(msk4mod != 0xD8) msk4_t msk4 <name="MSK4 Path", open=suppress>;
			    }msk4Header;
		    }
        } msk4Headers <name="MSK4 Headers">;
	}
	
	
	
	
	
	
    if(Header.effectCount){
        struct{
			for (a = 0; a < Header.effectCount; a++){
				struct Effect{
					uint32 eff_index <name="Effect Index">;
					uint32 utf8Hash <name="Name Hash">;
					uint32 ukn;
					uint32 SegmentCount <name="Segment Count">;
						for (b = 0; b < SegmentCount; b++){
							struct Segment{
								EffectGraphType typeId <name="Item Type ID", format=hex>;
								HeaderKind(typeId);
							}segment <name="Segment", read=GetSegmentName>;
						}
			
				}effect <name=Effect_Name>;
			}
        }effects <name="Effects">;
    }
	
	if (0 < Header.cndBlockCount){
        struct{
    			for (g = 0; g < Header.cndBlockCount; g++){
				struct Cnd_Block{
					uint32 utf16Hash <bgcolor=0x319fff, name="UTF-16 Name Hash">;
					uint32 utf8Hash <bgcolor=0x9494FF, name="UTF-8 Name Hash">;
					uint32 indexCount <name="Index Count", bgcolor=0x00BD00>;
					uint32 effectIndex[indexCount] <bgcolor=0x99FF99, name="Effect Index">;
				} cndBlock <name=Cnd_Block_Name>;
			}
        }cndBlocks <name="Condition Blocks">;
	}
	
	
	
	//struct{
	ubyte uknEndStruct[8];
	if(uknEndStruct[0] == 2){
		for (g = 0; g < uknEndStruct[0]; g++){
			struct{
				uint32 endStructPathSize <name="End Struct Path Size">;
				wchar_t endStructPath[endStructPathSize/2] <name="End Struct Path">;
			}uknEndStructPath;
	}
	}
	
    //}uknEndStruct <name="Condition Blocks">;
	
}

EFXTemplate();

if(h+i+j+red+green+blue+alpha > 0){
    FSeek(0);
	struct{
		if(0 < i){
			for(z = 0; z < i; z++){
				FSeek(spos[z]);
                small_cc small_color;
			}
		}

		if(0 < h){
			for(z = 0; z < h; z++){
				FSeek(mpos[z]);
                mid_cc mid_color;
			}
		}

		if(0 < j){
			for(z = 0; z < j; z++){
				FSeek(lpos[z]);
                large_cc largel_color;
			}
		}
		if(0 < red+green+blue+alpha){
            FSeek(0);
            struct{
			    for(z = 0; z < red; z++){
                    FSeek(redPos[z]-8);
                    struct{
				        FSeek(redPos[z]);
                        ubyte red <name="Red">;
				        FSeek(greenPos[z]);
                        ubyte green <name="Green">;
				        FSeek(bluePos[z]);
                        ubyte blue <name="Blue">;
				        FSeek(alphaPos[z]);
                        ubyte alpha <name="Alpha">;
				        FSeek(redPos[z]-8);
                        float redAppearTime <name="Red Appear Time">;
				        FSeek(greenPos[z]-8);
                        float greenAppearTime <name="Green Appear Time">;
				        FSeek(bluePos[z]-8);
                        float blueAppearTime <name="Blue Appear Time">;
				        FSeek(alphaPos[z]-8);
                        float alphaAppearTime <name="Alpha Appear Time">;
                        FSkip(8);
                    } cyclingColors <name="Cycling Colors (RGBA)">;
                    FSeek(4);
			    }
            } cycle <name="Cycling Colors (RGBA)">;
		}
		if(0 < onlyAlpha){
            FSeek(0);
            struct{
		        for(z = 0; z < onlyAlpha; z++){
                    FSeek(onlyAlphaPos[z]-8);
                    struct{
				        FSeek(onlyAlphaPos[z]);
                        ubyte alpha <name="Alpha">;
				        FSeek(onlyAlphaPos[z]-8);
                        float alphaAppearTime <name="Alpha Appear Time">;
                        FSkip(8);
                    } cyclingColors <name="Cycling Alphas">;
		        }
            FSeek(4);
            } cycle <name="Cycling Alphas">;
		}
		if(0 < alphaLessRed+alphaLessGreen+alphaLessBlue){
            FSeek(0);
            struct{
		        for(z = 0; z < alphaLessRed; z++){
                    FSeek(alphaLessRedPos[z]-8);
                    struct{
				        FSeek(alphaLessRedPos[z]);
                        ubyte noAlphaRed <name="Red">;
				        FSeek(alphaLessGreenPos[z]);
                        ubyte noAlphaGreen <name="Green">;
				        FSeek(alphaLessBluePos[z]);
                        ubyte noAlphaBlue <name="Blue">;
				        FSeek(alphaLessRedPos[z]-8);
                        float noAlphaRedAppearTime <name="Red Appear Time">;
				        FSeek(alphaLessGreenPos[z]-8);
                        float noAlphaGreenAppearTime <name="Green Appear Time">;
				        FSeek(alphaLessBluePos[z]-8);
                        float noAlphaBlueAppearTime <name="Blue Appear Time">;
                        FSkip(8);
                    } cyclingColors <name="Cycling Colors (RGB)">;
                    FSeek(4);
			    }
            } cycle <name="Cycling Colors (RGB)">;
		}
		if(0 < p){
			for(z = 0; z < p; z++){
				FSeek(fpos[z]);
                float_cc float_RGB;
			}
		}
        FSeek(4);
	} colorCodes <name="Color Codes">;
}